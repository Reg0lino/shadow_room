<!DOCTYPE html>
<html>
<head>
    <title>Model Poser Tool</title>
    <link rel="stylesheet" href="css/poser_style.css">
</head>
<body>
    <div id="wrapper">
        <!-- Controls Bar -->
        <div id="controls">
            <!-- Group 1: Transform Controls (MOVED TO FIRST) -->
            <div id="transformModeControls" class="controls-group" style="display: none;">
                <span>Transform:</span>
                <!-- Reordered Buttons -->
                <button id="rotateButton" class="transform-btn" data-mode="rotate">Rotate</button>
                <button id="translateButton" class="transform-btn" data-mode="translate">Translate</button>
                <button id="detachButton" title="Detach Transform Controls">Detach</button>
            </div>
            <!-- Group 2: Main Buttons -->
            <div class="controls-group">
                <label for="modelSelect">Model:</label>
                <select id="modelSelect" style="display: none;">
                    <option value="" disabled selected>-- Select Model --</option>
                </select>
                <button id="refreshModelButton" disabled title="Reload original model state">Refresh</button>
                <button id="savePoseDataBtn" disabled>Save Pose Data</button>
                <button id="wireframeButton" disabled>Toggle Wireframe</button>
                <button id="undoButton" disabled title="Undo (Ctrl+Z)">Undo</button>
                <button id="redoButton" disabled title="Redo (Ctrl+Y)">Redo</button>
                <button id="backToShadowRoomBtn">Back to Shadow Room</button>
            </div>
        </div>

        <!-- Container (Canvas Area) -->
        <div id="container">
            <div id="info">Load a GLB file</div>
            <!-- Canvas added by JS -->
        </div>

        <!-- Components Info Panel (Moves to bottom on mobile via CSS) -->
        <div id="componentsInfo" style="display: none;">
            <h3>Model Components</h3>
            <div id="summary"></div>
            <h4>Bones</h4>
            <div id="boneListContainer"></div>
            <details>
                <summary><h4>Meshes</h4></summary>
                <ul id="meshList"></ul>
            </details>
            <details>
                <summary><h4>Materials</h4></summary>
                <ul id="materialList"></ul>
            </details>
            <details>
                <summary><h4>Animations</h4></summary>
                <ul id="animationList"></ul>
            </details>
        </div>
        <!-- End #componentsInfo -->

    </div> <!-- End #wrapper -->

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // --- Existing poser.html JavaScript ---
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls, transformControls;
        let ambientLight, directionalLight, gridHelper, wireframeMaterial;
        let originalModelPath = '';
        let wireframeActive = false;
        let selectedBone = null;
        const originalMaterials = new Map();
        let loadedModelGroup = null;
        let modelCenter = new THREE.Vector3(0, 0, 0);
        const bones = [];
        const MAX_HISTORY = 50;
        let history = [];
        let historyIndex = -1;
        let initialBoneState = [];

        // --- DOM Element References ---
        const container = document.getElementById('container');
        const infoElement = document.getElementById('info');
        const componentsInfoElement = document.getElementById('componentsInfo');
        const summaryElement = document.getElementById('summary');
        const meshListElement = document.getElementById('meshList');
        const boneListContainer = document.getElementById('boneListContainer');
        let boneListElement = document.getElementById('boneList');
        const materialListElement = document.getElementById('materialList');
        const animationListElement = document.getElementById('animationList');
        const savePoseDataBtn = document.getElementById('savePoseDataBtn');
        const transformModeControls = document.getElementById('transformModeControls');
        const detachButton = document.getElementById('detachButton');
        const wireframeButton = document.getElementById('wireframeButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const refreshModelButton = document.getElementById('refreshModelButton');
        const backToShadowRoomBtn = document.getElementById('backToShadowRoomBtn');

        // --- Bone Mapping Configuration ---
        const boneMappingConfig = { /* ... Your existing config ... */ };

        // --- Initialization ---
        init();
        animate();

        // --- Functions ---
        function updateTransformButtonStyles() {
            const currentMode = transformControls.mode;
            document.querySelectorAll('.transform-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === currentMode);
            });
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(2, 2, 2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.5;
            controls.maxDistance = 50;

            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => { controls.enabled = !event.value; });
            transformControls.addEventListener('mouseUp', () => { if (selectedBone) saveHistoryState(); });
            transformControls.addEventListener('mode-changed', updateTransformButtonStyles);
            scene.add(transformControls);

            addLighting();

            gridHelper = new THREE.GridHelper(40, 40, 0x888888, 0x444444);
            gridHelper.position.y = 0;
            scene.add(gridHelper);

            wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, side: THREE.DoubleSide });

            // Event Listeners
            savePoseDataBtn.addEventListener('click', savePoseDataLocally);
            wireframeButton.addEventListener('click', toggleWireframe);
            undoButton.addEventListener('click', undo);
            redoButton.addEventListener('click', redo);
            refreshModelButton.addEventListener('click', refreshModel);
            backToShadowRoomBtn.addEventListener('click', () => window.close());

            document.getElementById('rotateButton').addEventListener('click', () => transformControls.setMode('rotate')); // Changed order
            document.getElementById('translateButton').addEventListener('click', () => transformControls.setMode('translate'));
            detachButton.addEventListener('click', () => {
                transformControls.detach();
                selectedBone = null;
                boneListContainer.querySelector('li.selected')?.classList.remove('selected');
                controls.target.copy(modelCenter);
                controls.update();
            });

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', handleKeyDown);

            loadModelFromUrlParam();

            // <<< Set Default Transform Mode to Rotate >>>
            transformControls.setMode('rotate');
            updateTransformButtonStyles(); // Update highlights
        }

        // ... (rest of the existing JavaScript functions remain the same) ...
        // loadModelFromUrlParam, addLighting, animate, onWindowResize,
        // clearScene, loadSelectedModel, loadGLB, populateComponentsInfo,
        // populateBoneList, handleBoneClick, toggleWireframe, saveInitialState,
        // refreshModel, saveHistoryState, applyHistoryState, undo, redo,
        // updateUndoRedoButtons, handleKeyDown, savePoseDataLocally, setInfo

        function onWindowResize() {
            if (!container || !camera || !renderer) return;
            const width = container.clientWidth;
            const height = container.clientHeight;
            if (width > 0 && height > 0) {
                 camera.aspect = width / height;
                 camera.updateProjectionMatrix();
                 renderer.setSize(width, height);
            } else {
                 console.warn(`Resize ignored: Invalid container dimensions ${width}x${height}`);
            }
        }

        function clearScene() {
            transformControls.detach();
            if (loadedModelGroup) {
                scene.remove(loadedModelGroup);
                loadedModelGroup.traverse(child => {
                    if (child.isMesh) {
                        child.geometry?.dispose();
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(m => m?.dispose());
                    }
                });
                 // console.log("Previous model removed.");
            }
            loadedModelGroup = null;
            bones.length = 0;
            selectedBone = null;
            history = [];
            historyIndex = -1;
            initialBoneState = [];
            originalMaterials.clear();
            wireframeActive = false;
            updateUndoRedoButtons();

            meshListElement.innerHTML = '';
            boneListContainer.innerHTML = '';
            materialListElement.innerHTML = '';
            animationListElement.innerHTML = '';
            summaryElement.innerHTML = '';
        }
        function loadSelectedModel(modelPath) {
             clearScene();
             setInfo(`Loading ${modelPath}...`, 'loading');
             componentsInfoElement.style.display = 'none';

             savePoseDataBtn.disabled = true;
             transformModeControls.style.display = 'none';
             wireframeButton.disabled = true;
             undoButton.disabled = true;
             redoButton.disabled = true;
             refreshModelButton.disabled = true;

             fetch(modelPath)
                 .then(response => {
                     if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${modelPath}`);
                     return response.arrayBuffer();
                 })
                 .then(buffer => loadGLB(buffer, modelPath.split('/').pop()))
                 .catch(error => {
                     console.error('Error fetching/loading model:', error);
                     setInfo(`Error loading: ${error.message}`, 'error');
                     clearScene();
                 });
        }
        function loadGLB(data, filename) {
            const loader = new GLTFLoader();
            loader.parse(data, '', (gltf) => {
                loadedModelGroup = gltf.scene;
                loadedModelGroup.animations = gltf.animations;
                const box = new THREE.Box3().setFromObject(loadedModelGroup);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = maxDim > 0 ? 2.0 / maxDim : 1.0;
                loadedModelGroup.scale.set(scale, scale, scale);
                loadedModelGroup.updateMatrixWorld(true);
                const scaledBox = new THREE.Box3().setFromObject(loadedModelGroup);
                const scaledCenter = scaledBox.getCenter(new THREE.Vector3());
                const scaledBottomY = scaledBox.min.y;
                loadedModelGroup.position.set(-scaledCenter.x, -scaledBottomY, -scaledCenter.z);
                modelCenter.set(0, scaledBox.getSize(new THREE.Vector3()).y / 2, 0);
                modelCenter.add(loadedModelGroup.position);
                controls.target.copy(modelCenter);
                controls.update();
                loadedModelGroup.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        originalMaterials.set(child, child.material);
                    }
                });
                scene.add(loadedModelGroup);
                populateComponentsInfo(gltf, filename);
                setInfo(`Loaded ${filename}`, 'success');
                savePoseDataBtn.disabled = false;
                wireframeButton.disabled = false;
                refreshModelButton.disabled = false;
                transformModeControls.style.display = 'flex';
                saveInitialState();
                saveHistoryState();
                onWindowResize();
            }, (error) => {
                console.error('Error parsing GLB:', error);
                setInfo(`Error parsing ${filename}: ${error}`, 'error');
                clearScene();
            });
        }
        function populateComponentsInfo(gltf, filename) {
             meshListElement.innerHTML = '';
             boneListContainer.innerHTML = '';
             materialListElement.innerHTML = '';
             animationListElement.innerHTML = '';
             bones.length = 0;
             let meshCount = 0;
             let materialCount = 0;
             const uniqueMaterials = new Set();
             gltf.scene.traverse((child) => {
                 if (child.isMesh) {
                     meshCount++;
                     const li = document.createElement('li');
                     li.textContent = child.name || `Mesh ${meshCount}`;
                     meshListElement.appendChild(li);
                     const materials = Array.isArray(child.material) ? child.material : [child.material];
                     materials.forEach(mat => mat && uniqueMaterials.add(mat));
                 }
                 if (child.isBone) bones.push(child);
             });
             uniqueMaterials.forEach((mat) => {
                 materialCount++;
                 const li = document.createElement('li');
                 li.textContent = mat.name || `Material ${materialCount}`;
                 materialListElement.appendChild(li);
             });
             populateBoneList();
             if (gltf.animations && gltf.animations.length > 0) {
                 gltf.animations.forEach((clip) => {
                     const li = document.createElement('li');
                     li.textContent = clip.name || 'Animation Clip';
                     animationListElement.appendChild(li);
                 });
             } else {
                 animationListElement.innerHTML = '<li>No animations found</li>';
             }
             summaryElement.innerHTML = `<strong>Filename:</strong> ${filename}<br><strong>Bones:</strong> ${bones.length}`;
             componentsInfoElement.style.display = 'block';
        }
        function populateBoneList() {
             boneListContainer.innerHTML = '';
             const modelMapping = boneMappingConfig[originalModelPath];
             if (!modelMapping) {
                  console.warn(`No bone mapping for ${originalModelPath}.`);
                  const ul = document.createElement('ul');
                  bones.sort((a, b) => a.name.localeCompare(b.name)).forEach(bone => {
                      ul.appendChild(createAndAttachListItem({ bone: bone, friendlyName: bone.name || 'Unnamed Bone' }));
                  });
                  boneListContainer.appendChild(ul);
                  return;
             }
             const groupedBones = {};
             const groupOrder = ['Root', 'Rigging', 'Head', 'Torso', 'Arms', 'Hands', 'Legs', 'Feet', 'Other'];
             bones.forEach(bone => {
                 const mappingInfo = modelMapping[bone.name];
                 const boneInfo = { bone: bone, friendlyName: mappingInfo?.friendlyName || bone.name || 'Unnamed Bone', group: mappingInfo?.group || 'Other', subGroup: mappingInfo?.subGroup };
                 if (!groupedBones[boneInfo.group]) groupedBones[boneInfo.group] = { _root: [] };
                 const targetSubGroup = boneInfo.subGroup && boneInfo.subGroup !== '_root' ? boneInfo.subGroup : '_root';
                 if (!groupedBones[boneInfo.group][targetSubGroup]) groupedBones[boneInfo.group][targetSubGroup] = [];
                 groupedBones[boneInfo.group][targetSubGroup].push(boneInfo);
             });
             groupOrder.forEach(groupName => {
                 const groupData = groupedBones[groupName];
                 if (!groupData) return;
                 const groupDetails = document.createElement('details');
                 groupDetails.open = !['Hands', 'Feet', 'Rigging', 'Other'].includes(groupName);
                 const groupSummary = document.createElement('summary');
                 groupSummary.textContent = groupName;
                 groupDetails.appendChild(groupSummary);
                 const groupUl = document.createElement('ul');
                 groupData._root.sort((a,b) => a.friendlyName.localeCompare(b.friendlyName)).forEach(boneInfo => { groupUl.appendChild(createAndAttachListItem(boneInfo)); });
                 Object.keys(groupData).sort().forEach(subGroupName => {
                     if (subGroupName === '_root') return;
                     const subGroupDetails = document.createElement('details');
                     subGroupDetails.open = false;
                     const subGroupSummary = document.createElement('summary');
                     subGroupSummary.textContent = subGroupName;
                     subGroupDetails.appendChild(subGroupSummary);
                     const subGroupUl = document.createElement('ul');
                     groupData[subGroupName].sort((a,b) => a.friendlyName.localeCompare(b.friendlyName)).forEach(boneInfo => { subGroupUl.appendChild(createAndAttachListItem(boneInfo)); });
                     subGroupDetails.appendChild(subGroupUl);
                     groupUl.appendChild(subGroupDetails);
                 });
                 groupDetails.appendChild(groupUl);
                 boneListContainer.appendChild(groupDetails);
             });
             function createAndAttachListItem(boneInfo) {
                 const li = document.createElement('li');
                 li.textContent = boneInfo.friendlyName;
                 li.dataset.boneName = boneInfo.bone.name;
                 li.addEventListener('click', handleBoneClick);
                 return li;
             }
        }
        function handleBoneClick(event) {
             const li = event.currentTarget;
             const boneName = li.dataset.boneName;
             const targetBone = bones.find(b => b.name === boneName);
             if (!targetBone) return;
             boneListContainer.querySelector('li.selected')?.classList.remove('selected');
             li.classList.add('selected');
             selectedBone = targetBone;
             transformControls.attach(targetBone);
             const boneWorldPosition = new THREE.Vector3();
             targetBone.getWorldPosition(boneWorldPosition);
             controls.target.copy(boneWorldPosition);
             controls.update();
        }
        function toggleWireframe() {
             if (!loadedModelGroup) return;
             wireframeActive = !wireframeActive;
             loadedModelGroup.traverse((child) => {
                 if (child.isMesh) {
                     if (wireframeActive) {
                         if (!originalMaterials.has(child)) originalMaterials.set(child, child.material);
                         child.material = wireframeMaterial;
                     } else {
                         if (originalMaterials.has(child)) child.material = originalMaterials.get(child);
                     }
                 }
             });
              console.log(`Wireframe ${wireframeActive ? 'on' : 'off'}`);
        }
        function saveInitialState() {
             initialBoneState = bones.map(bone => ({ name: bone.name, position: bone.position.clone(), quaternion: bone.quaternion.clone(), scale: bone.scale.clone() }));
        }
        function refreshModel() {
             if (!originalModelPath) { setInfo("Cannot refresh: No model loaded.", "error"); return; }
             setInfo(`Refreshing: ${originalModelPath}`, 'loading');
             loadSelectedModel(originalModelPath);
        }
        function saveHistoryState() {
             if (!loadedModelGroup || bones.length === 0) return;
             const currentState = bones.map(bone => ({ name: bone.name, position: bone.position.clone(), quaternion: bone.quaternion.clone(), scale: bone.scale.clone() }));
             if (historyIndex < history.length - 1) history.length = historyIndex + 1;
             history.push(currentState);
             if (history.length > MAX_HISTORY) history.shift();
             historyIndex = history.length - 1;
             updateUndoRedoButtons();
        }
        function applyHistoryState(stateIndex) {
             if (stateIndex < 0 || stateIndex >= history.length) return;
             const stateToApply = history[stateIndex];
             let boneFound = false;
             stateToApply.forEach(boneState => {
                 const bone = bones.find(b => b.name === boneState.name);
                 if (bone) { bone.position.copy(boneState.position); bone.quaternion.copy(boneState.quaternion); bone.scale.copy(boneState.scale); boneFound = true; }
             });
             if (boneFound && loadedModelGroup) { loadedModelGroup.traverse(obj => { if (obj.isSkinnedMesh) obj.skeleton.update(); }); }
             historyIndex = stateIndex;
             updateUndoRedoButtons();
             if (selectedBone) {
                  transformControls.attach(selectedBone);
                  const boneWorldPosition = new THREE.Vector3();
                  selectedBone.getWorldPosition(boneWorldPosition);
                  controls.target.copy(boneWorldPosition);
                  controls.update();
             } else {
                  transformControls.detach();
                  controls.target.copy(modelCenter);
                  controls.update();
             }
        }
        function undo() { if (historyIndex > 0) applyHistoryState(historyIndex - 1); }
        function redo() { if (historyIndex < history.length - 1) applyHistoryState(historyIndex + 1); }
        function updateUndoRedoButtons() {
             undoButton.disabled = historyIndex <= 0;
             redoButton.disabled = historyIndex >= history.length - 1;
        }
        function handleKeyDown(event) {
             if (document.activeElement && ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
             const isCtrlOrCmd = event.ctrlKey || event.metaKey;
             if (isCtrlOrCmd && event.key.toLowerCase() === 'z') { event.preventDefault(); undo(); }
             else if (isCtrlOrCmd && event.key.toLowerCase() === 'y') { event.preventDefault(); redo(); }
             else if (event.key.toLowerCase() === 't') { event.preventDefault(); transformControls.setMode('translate'); }
             else if (event.key.toLowerCase() === 'r') { event.preventDefault(); transformControls.setMode('rotate'); }
             else if (event.key === 'Escape') { event.preventDefault(); detachButton.click(); }
        }
        function savePoseDataLocally() {
             if (!loadedModelGroup || !originalModelPath || bones.length === 0) { setInfo('Load a model with bones first.', 'error'); return; }
             const poseName = prompt("Enter a name for this pose:", "New Pose");
             if (!poseName || poseName.trim() === "") { setInfo('Save cancelled.', 'info'); return; }
             const trimmedPoseName = poseName.trim();
             setInfo(`Saving pose "${trimmedPoseName}"...`, 'loading');
             try {
                 const currentPoseData = bones.map(bone => ({ name: bone.name, position: bone.position.toArray(), quaternion: bone.quaternion.toArray(), scale: bone.scale.toArray() }));
                 const storageKey = `poses_${originalModelPath}`;
                 let existingPoses = {};
                 try { const storedData = localStorage.getItem(storageKey); if (storedData) existingPoses = JSON.parse(storedData); if (typeof existingPoses !== 'object' || existingPoses === null) existingPoses = {}; } catch (e) { console.error(`Error parsing pose data for ${storageKey}:`, e); existingPoses = {}; }
                 existingPoses[trimmedPoseName] = currentPoseData;
                 localStorage.setItem(storageKey, JSON.stringify(existingPoses));
                 setInfo(`Pose "${trimmedPoseName}" saved. Refresh Shadow Room.`, 'success');
                 console.log(`Pose "${trimmedPoseName}" saved to key: ${storageKey}`);
             } catch (saveError) { console.error('Error saving pose data:', saveError); setInfo(`Save failed: ${saveError.message}`, 'error'); }
        }
        function setInfo(message, type = 'info') {
             if (!infoElement) return;
             infoElement.textContent = message;
             infoElement.className = type;
        }

    </script>

</body>
</html>