<!DOCTYPE html>
<html>
<head>
    <title>Model Poser Tool</title> <!-- UPDATED TITLE -->
    <!-- Add link to the new CSS file -->
    <link rel="stylesheet" href="css/poser_style.css">
</head>
<body>
    <div id="controls">
        <label for="modelSelect">Model:</label>
        <select id="modelSelect" style="display: none;">
            <option value="" disabled selected>-- Select Model --</option>
        </select>
        <button id="refreshModelButton" disabled title="Reload original model state">Refresh</button>
        <button id="savePoseDataBtn" disabled>Save Pose Data</button>
        <button id="wireframeButton" disabled>Toggle Wireframe</button>
        <button id="undoButton" disabled title="Undo (Ctrl+Z)">Undo</button>
        <button id="redoButton" disabled title="Redo (Ctrl+Y)">Redo</button>
        <button id="backToShadowRoomBtn">Back to Shadow Room</button>
        <div id="transformModeControls" style="display: none;">
            <span>Transform:</span>
            <button id="translateButton" class="transform-btn" data-mode="translate">Translate</button>
            <button id="rotateButton" class="transform-btn" data-mode="rotate">Rotate</button>
            <button id="detachButton" title="Detach Transform Controls">Detach</button>
        </div>
    </div>
    <div id="container">
        <div id="info">Load a GLB file</div>
        <div id="componentsInfo" style="display: none;">
            <h3>Model Components</h3>
            <div id="summary"></div> <!-- Summary remains here -->

            <h4>Bones</h4> <!-- Bones section moved up -->
            <div id="boneListContainer">
                <!-- Content generated by JS -->
            </div>

            <!-- Meshes (Collapsible) -->
            <details>
                <summary><h4>Meshes</h4></summary>
                <ul id="meshList"></ul>
            </details>

            <!-- Materials (Collapsible) -->
            <details>
                <summary><h4>Materials</h4></summary>
                <ul id="materialList"></ul>
            </details>

            <!-- Animations (Collapsible) -->
            <details>
                <summary><h4>Animations</h4></summary>
                <ul id="animationList"></ul>
            </details>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls, transformControls;
        let ambientLight, directionalLight, gridHelper, wireframeMaterial;
        let originalModelPath = ''; // Store the path of the loaded model
        let wireframeActive = false; // Track wireframe state
        let selectedBone = null;
        const originalMaterials = new Map();
        let loadedModelGroup = null; // Group to hold the loaded model
        let modelCenter = new THREE.Vector3(0, 0, 0);
        const bones = []; // Array to hold bone objects
        const MAX_HISTORY = 50;
        let history = [];
        let historyIndex = -1;
        let initialBoneState = [];

        // --- DOM Element References ---
        const container = document.getElementById('container');
        const infoElement = document.getElementById('info');
        const componentsInfoElement = document.getElementById('componentsInfo');
        const summaryElement = document.getElementById('summary');
        const meshListElement = document.getElementById('meshList');
        const boneListContainer = document.getElementById('boneListContainer');
        let boneListElement = document.getElementById('boneList'); // Will be recreated
        const materialListElement = document.getElementById('materialList');
        const animationListElement = document.getElementById('animationList');
        const savePoseDataBtn = document.getElementById('savePoseDataBtn');
        const transformModeControls = document.getElementById('transformModeControls');
        const detachButton = document.getElementById('detachButton');
        const wireframeButton = document.getElementById('wireframeButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const refreshModelButton = document.getElementById('refreshModelButton');
        const backToShadowRoomBtn = document.getElementById('backToShadowRoomBtn');


        // --- Bone Mapping Configuration (Populated) ---
        const boneMappingConfig = {
            'models/male_base0.glb': {
                // Torso & Head
                'hip': { friendlyName: 'Hips', group: 'Torso' },
                'spine001': { friendlyName: 'Spine 1', group: 'Torso' },
                'spine002': { friendlyName: 'Spine 2', group: 'Torso' },
                'spine003': { friendlyName: 'Spine 3', group: 'Torso' },
                'neck': { friendlyName: 'Neck', group: 'Head' },
                'head': { friendlyName: 'Head', group: 'Head' },
                // Left Arm
                'shoulderL': { friendlyName: 'Shoulder L', group: 'Arms' },
                'upper_armL': { friendlyName: 'Upper Arm L', group: 'Arms' },
                'forearmL': { friendlyName: 'Forearm L', group: 'Arms' },
                'handL': { friendlyName: 'Hand L', group: 'Hands', subGroup: '_root' },
                // Left Hand
                'palm01L': { friendlyName: 'Palm Index L', group: 'Hands', subGroup: 'Left Palm' },
                'f_index01L': { friendlyName: 'Index 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index02L': { friendlyName: 'Index 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index03L': { friendlyName: 'Index 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb01L': { friendlyName: 'Thumb 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb02L': { friendlyName: 'Thumb 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb03L': { friendlyName: 'Thumb 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm02L': { friendlyName: 'Palm Middle L', group: 'Hands', subGroup: 'Left Palm' },
                'f_middle01L': { friendlyName: 'Middle 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle02L': { friendlyName: 'Middle 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle03L': { friendlyName: 'Middle 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm03L': { friendlyName: 'Palm Ring L', group: 'Hands', subGroup: 'Left Palm' },
                'f_ring01L': { friendlyName: 'Ring 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring02L': { friendlyName: 'Ring 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring03L': { friendlyName: 'Ring 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm04L': { friendlyName: 'Palm Pinky L', group: 'Hands', subGroup: 'Left Palm' },
                'f_pinky01L': { friendlyName: 'Pinky 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky02L': { friendlyName: 'Pinky 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky03L': { friendlyName: 'Pinky 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                // Right Arm
                'shoulderR': { friendlyName: 'Shoulder R', group: 'Arms' },
                'upper_armR': { friendlyName: 'Upper Arm R', group: 'Arms' },
                'forearmR': { friendlyName: 'Forearm R', group: 'Arms' },
                'handR': { friendlyName: 'Hand R', group: 'Hands', subGroup: '_root' },
                // Right Hand
                'palm01R': { friendlyName: 'Palm Index R', group: 'Hands', subGroup: 'Right Palm' },
                'f_index01R': { friendlyName: 'Index 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index02R': { friendlyName: 'Index 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index03R': { friendlyName: 'Index 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb01R': { friendlyName: 'Thumb 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb02R': { friendlyName: 'Thumb 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb03R': { friendlyName: 'Thumb 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm02R': { friendlyName: 'Palm Middle R', group: 'Hands', subGroup: 'Right Palm' },
                'f_middle01R': { friendlyName: 'Middle 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle02R': { friendlyName: 'Middle 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle03R': { friendlyName: 'Middle 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm03R': { friendlyName: 'Palm Ring R', group: 'Hands', subGroup: 'Right Palm' },
                'f_ring01R': { friendlyName: 'Ring 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring02R': { friendlyName: 'Ring 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring03R': { friendlyName: 'Ring 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm04R': { friendlyName: 'Palm Pinky R', group: 'Hands', subGroup: 'Right Palm' },
                'f_pinky01R': { friendlyName: 'Pinky 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky02R': { friendlyName: 'Pinky 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky03R': { friendlyName: 'Pinky 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                // Left Leg
                'pelvisL': { friendlyName: 'Pelvis L', group: 'Legs' },
                'thighL': { friendlyName: 'Thigh L', group: 'Legs' },
                'shinL': { friendlyName: 'Shin L', group: 'Legs' },
                'footL': { friendlyName: 'Foot L', group: 'Feet' },
                'toeL': { friendlyName: 'Toe L', group: 'Feet' },
                // Right Leg
                'pelvisR': { friendlyName: 'Pelvis R', group: 'Legs' },
                'thighR': { friendlyName: 'Thigh R', group: 'Legs' },
                'shinR': { friendlyName: 'Shin R', group: 'Legs' },
                'footR': { friendlyName: 'Foot R', group: 'Feet' },
                'toeR': { friendlyName: 'Toe R', group: 'Feet' },
            },
            'models/male_base1.glb': { // Assumed same as male_base0 based on list
                // Torso & Head
                'hip': { friendlyName: 'Hips', group: 'Torso' },
                'spine001': { friendlyName: 'Spine 1', group: 'Torso' },
                'spine002': { friendlyName: 'Spine 2', group: 'Torso' },
                'spine003': { friendlyName: 'Spine 3', group: 'Torso' },
                'neck': { friendlyName: 'Neck', group: 'Head' },
                'head': { friendlyName: 'Head', group: 'Head' },
                // Left Arm
                'shoulderL': { friendlyName: 'Shoulder L', group: 'Arms' },
                'upper_armL': { friendlyName: 'Upper Arm L', group: 'Arms' },
                'forearmL': { friendlyName: 'Forearm L', group: 'Arms' },
                'handL': { friendlyName: 'Hand L', group: 'Hands', subGroup: '_root' },
                // Left Hand
                'palm01L': { friendlyName: 'Palm Index L', group: 'Hands', subGroup: 'Left Palm' },
                'f_index01L': { friendlyName: 'Index 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index02L': { friendlyName: 'Index 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index03L': { friendlyName: 'Index 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb01L': { friendlyName: 'Thumb 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb02L': { friendlyName: 'Thumb 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb03L': { friendlyName: 'Thumb 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm02L': { friendlyName: 'Palm Middle L', group: 'Hands', subGroup: 'Left Palm' },
                'f_middle01L': { friendlyName: 'Middle 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle02L': { friendlyName: 'Middle 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle03L': { friendlyName: 'Middle 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm03L': { friendlyName: 'Palm Ring L', group: 'Hands', subGroup: 'Left Palm' },
                'f_ring01L': { friendlyName: 'Ring 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring02L': { friendlyName: 'Ring 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring03L': { friendlyName: 'Ring 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm04L': { friendlyName: 'Palm Pinky L', group: 'Hands', subGroup: 'Left Palm' },
                'f_pinky01L': { friendlyName: 'Pinky 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky02L': { friendlyName: 'Pinky 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky03L': { friendlyName: 'Pinky 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                // Right Arm
                'shoulderR': { friendlyName: 'Shoulder R', group: 'Arms' },
                'upper_armR': { friendlyName: 'Upper Arm R', group: 'Arms' },
                'forearmR': { friendlyName: 'Forearm R', group: 'Arms' },
                'handR': { friendlyName: 'Hand R', group: 'Hands', subGroup: '_root' },
                // Right Hand
                'palm01R': { friendlyName: 'Palm Index R', group: 'Hands', subGroup: 'Right Palm' },
                'f_index01R': { friendlyName: 'Index 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index02R': { friendlyName: 'Index 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index03R': { friendlyName: 'Index 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb01R': { friendlyName: 'Thumb 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb02R': { friendlyName: 'Thumb 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb03R': { friendlyName: 'Thumb 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm02R': { friendlyName: 'Palm Middle R', group: 'Hands', subGroup: 'Right Palm' },
                'f_middle01R': { friendlyName: 'Middle 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle02R': { friendlyName: 'Middle 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle03R': { friendlyName: 'Middle 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm03R': { friendlyName: 'Palm Ring R', group: 'Hands', subGroup: 'Right Palm' },
                'f_ring01R': { friendlyName: 'Ring 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring02R': { friendlyName: 'Ring 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring03R': { friendlyName: 'Ring 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm04R': { friendlyName: 'Palm Pinky R', group: 'Hands', subGroup: 'Right Palm' },
                'f_pinky01R': { friendlyName: 'Pinky 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky02R': { friendlyName: 'Pinky 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky03R': { friendlyName: 'Pinky 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                // Left Leg
                'pelvisL': { friendlyName: 'Pelvis L', group: 'Legs' },
                'thighL': { friendlyName: 'Thigh L', group: 'Legs' },
                'shinL': { friendlyName: 'Shin L', group: 'Legs' },
                'footL': { friendlyName: 'Foot L', group: 'Feet' },
                'toeL': { friendlyName: 'Toe L', group: 'Feet' },
                // Right Leg
                'pelvisR': { friendlyName: 'Pelvis R', group: 'Legs' },
                'thighR': { friendlyName: 'Thigh R', group: 'Legs' },
                'shinR': { friendlyName: 'Shin R', group: 'Legs' },
                'footR': { friendlyName: 'Foot R', group: 'Feet' },
                'toeR': { friendlyName: 'Toe R', group: 'Feet' },
            },
            'models/male_base2.glb': { // Assumed same as jumping_man based on list
                // Root & Torso
                'metarig_rootJoint': { friendlyName: 'Root', group: 'Root' },
                'hips_metarig': { friendlyName: 'Hips', group: 'Torso' },
                'spine_metarig': { friendlyName: 'Spine', group: 'Torso' },
                'chest_metarig': { friendlyName: 'Chest', group: 'Torso' },
                // Head
                'neck_metarig': { friendlyName: 'Neck', group: 'Head' },
                'head_metarig': { friendlyName: 'Head', group: 'Head' },
                // Left Arm
                'shoulderL_metarig': { friendlyName: 'Shoulder L', group: 'Arms' },
                'upper_armL_metarig': { friendlyName: 'Upper Arm L', group: 'Arms' },
                'forearmL_metarig': { friendlyName: 'Forearm L', group: 'Arms' },
                'handL_metarig': { friendlyName: 'Hand L', group: 'Hands', subGroup: '_root' },
                // Left Hand
                'palm01L_metarig': { friendlyName: 'Palm Index L', group: 'Hands', subGroup: 'Left Palm' },
                'f_index01L_metarig': { friendlyName: 'Index 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index02L_metarig': { friendlyName: 'Index 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index03L_metarig': { friendlyName: 'Index 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb01L_metarig': { friendlyName: 'Thumb 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb02L_metarig': { friendlyName: 'Thumb 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb03L_metarig': { friendlyName: 'Thumb 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm02L_metarig': { friendlyName: 'Palm Middle L', group: 'Hands', subGroup: 'Left Palm' },
                'f_middle01L_metarig': { friendlyName: 'Middle 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle02L_metarig': { friendlyName: 'Middle 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle03L_metarig': { friendlyName: 'Middle 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm03L_metarig': { friendlyName: 'Palm Ring L', group: 'Hands', subGroup: 'Left Palm' },
                'f_ring01L_metarig': { friendlyName: 'Ring 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring02L_metarig': { friendlyName: 'Ring 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring03L_metarig': { friendlyName: 'Ring 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm04L_metarig': { friendlyName: 'Palm Pinky L', group: 'Hands', subGroup: 'Left Palm' },
                'f_pinky01L_metarig': { friendlyName: 'Pinky 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky02L_metarig': { friendlyName: 'Pinky 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky03L_metarig': { friendlyName: 'Pinky 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                // Right Arm
                'shoulderR_metarig': { friendlyName: 'Shoulder R', group: 'Arms' },
                'upper_armR_metarig': { friendlyName: 'Upper Arm R', group: 'Arms' },
                'forearmR_metarig': { friendlyName: 'Forearm R', group: 'Arms' },
                'handR_metarig': { friendlyName: 'Hand R', group: 'Hands', subGroup: '_root' },
                // Right Hand
                'palm01R_metarig': { friendlyName: 'Palm Index R', group: 'Hands', subGroup: 'Right Palm' },
                'f_index01R_metarig': { friendlyName: 'Index 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index02R_metarig': { friendlyName: 'Index 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index03R_metarig': { friendlyName: 'Index 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb01R_metarig': { friendlyName: 'Thumb 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb02R_metarig': { friendlyName: 'Thumb 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb03R_metarig': { friendlyName: 'Thumb 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm02R_metarig': { friendlyName: 'Palm Middle R', group: 'Hands', subGroup: 'Right Palm' },
                'f_middle01R_metarig': { friendlyName: 'Middle 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle02R_metarig': { friendlyName: 'Middle 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle03R_metarig': { friendlyName: 'Middle 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm03R_metarig': { friendlyName: 'Palm Ring R', group: 'Hands', subGroup: 'Right Palm' },
                'f_ring01R_metarig': { friendlyName: 'Ring 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring02R_metarig': { friendlyName: 'Ring 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring03R_metarig': { friendlyName: 'Ring 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm04R_metarig': { friendlyName: 'Palm Pinky R', group: 'Hands', subGroup: 'Right Palm' },
                'f_pinky01R_metarig': { friendlyName: 'Pinky 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky02R_metarig': { friendlyName: 'Pinky 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky03R_metarig': { friendlyName: 'Pinky 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                // Left Leg
                'thighL_metarig': { friendlyName: 'Thigh L', group: 'Legs' },
                'shinL_metarig': { friendlyName: 'Shin L', group: 'Legs' },
                'footL_metarig': { friendlyName: 'Foot L', group: 'Feet' },
                'toeL_metarig': { friendlyName: 'Toe L', group: 'Feet' },
                'heelL_metarig': { friendlyName: 'Heel L', group: 'Feet' },
                'heel02L_metarig': { friendlyName: 'Heel Top L', group: 'Feet' },
                // Right Leg
                'thighR_metarig': { friendlyName: 'Thigh R', group: 'Legs' },
                'shinR_metarig': { friendlyName: 'Shin R', group: 'Legs' },
                'footR_metarig': { friendlyName: 'Foot R', group: 'Feet' },
                'toeR_metarig': { friendlyName: 'Toe R', group: 'Feet' },
                'heelR_metarig': { friendlyName: 'Heel R', group: 'Feet' },
                'heel02R_metarig': { friendlyName: 'Heel Top R', group: 'Feet' },
            },
            'models/jumping_man.glb': { // Assumed same as male_base2 based on list
                // Root & Torso
                'metarig_rootJoint': { friendlyName: 'Root', group: 'Root' },
                'hips_metarig': { friendlyName: 'Hips', group: 'Torso' },
                'spine_metarig': { friendlyName: 'Spine', group: 'Torso' },
                'chest_metarig': { friendlyName: 'Chest', group: 'Torso' },
                // Head
                'neck_metarig': { friendlyName: 'Neck', group: 'Head' },
                'head_metarig': { friendlyName: 'Head', group: 'Head' },
                // Left Arm
                'shoulderL_metarig': { friendlyName: 'Shoulder L', group: 'Arms' },
                'upper_armL_metarig': { friendlyName: 'Upper Arm L', group: 'Arms' },
                'forearmL_metarig': { friendlyName: 'Forearm L', group: 'Arms' },
                'handL_metarig': { friendlyName: 'Hand L', group: 'Hands', subGroup: '_root' },
                // Left Hand
                'palm01L_metarig': { friendlyName: 'Palm Index L', group: 'Hands', subGroup: 'Left Palm' },
                'f_index01L_metarig': { friendlyName: 'Index 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index02L_metarig': { friendlyName: 'Index 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index03L_metarig': { friendlyName: 'Index 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb01L_metarig': { friendlyName: 'Thumb 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb02L_metarig': { friendlyName: 'Thumb 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb03L_metarig': { friendlyName: 'Thumb 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm02L_metarig': { friendlyName: 'Palm Middle L', group: 'Hands', subGroup: 'Left Palm' },
                'f_middle01L_metarig': { friendlyName: 'Middle 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle02L_metarig': { friendlyName: 'Middle 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle03L_metarig': { friendlyName: 'Middle 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm03L_metarig': { friendlyName: 'Palm Ring L', group: 'Hands', subGroup: 'Left Palm' },
                'f_ring01L_metarig': { friendlyName: 'Ring 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring02L_metarig': { friendlyName: 'Ring 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring03L_metarig': { friendlyName: 'Ring 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm04L_metarig': { friendlyName: 'Palm Pinky L', group: 'Hands', subGroup: 'Left Palm' },
                'f_pinky01L_metarig': { friendlyName: 'Pinky 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky02L_metarig': { friendlyName: 'Pinky 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky03L_metarig': { friendlyName: 'Pinky 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                // Right Arm
                'shoulderR_metarig': { friendlyName: 'Shoulder R', group: 'Arms' },
                'upper_armR_metarig': { friendlyName: 'Upper Arm R', group: 'Arms' },
                'forearmR_metarig': { friendlyName: 'Forearm R', group: 'Arms' },
                'handR_metarig': { friendlyName: 'Hand R', group: 'Hands', subGroup: '_root' },
                // Right Hand
                'palm01R_metarig': { friendlyName: 'Palm Index R', group: 'Hands', subGroup: 'Right Palm' },
                'f_index01R_metarig': { friendlyName: 'Index 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index02R_metarig': { friendlyName: 'Index 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index03R_metarig': { friendlyName: 'Index 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb01R_metarig': { friendlyName: 'Thumb 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb02R_metarig': { friendlyName: 'Thumb 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb03R_metarig': { friendlyName: 'Thumb 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm02R_metarig': { friendlyName: 'Palm Middle R', group: 'Hands', subGroup: 'Right Palm' },
                'f_middle01R_metarig': { friendlyName: 'Middle 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle02R_metarig': { friendlyName: 'Middle 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle03R_metarig': { friendlyName: 'Middle 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm03R_metarig': { friendlyName: 'Palm Ring R', group: 'Hands', subGroup: 'Right Palm' },
                'f_ring01R_metarig': { friendlyName: 'Ring 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring02R_metarig': { friendlyName: 'Ring 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring03R_metarig': { friendlyName: 'Ring 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm04R_metarig': { friendlyName: 'Palm Pinky R', group: 'Hands', subGroup: 'Right Palm' },
                'f_pinky01R_metarig': { friendlyName: 'Pinky 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky02R_metarig': { friendlyName: 'Pinky 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky03R_metarig': { friendlyName: 'Pinky 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                // Left Leg
                'thighL_metarig': { friendlyName: 'Thigh L', group: 'Legs' },
                'shinL_metarig': { friendlyName: 'Shin L', group: 'Legs' },
                'footL_metarig': { friendlyName: 'Foot L', group: 'Feet' },
                'toeL_metarig': { friendlyName: 'Toe L', group: 'Feet' },
                'heelL_metarig': { friendlyName: 'Heel L', group: 'Feet' },
                'heel02L_metarig': { friendlyName: 'Heel Top L', group: 'Feet' },
                // Right Leg
                'thighR_metarig': { friendlyName: 'Thigh R', group: 'Legs' },
                'shinR_metarig': { friendlyName: 'Shin R', group: 'Legs' },
                'footR_metarig': { friendlyName: 'Foot R', group: 'Feet' },
                'toeR_metarig': { friendlyName: 'Toe R', group: 'Feet' },
                'heelR_metarig': { friendlyName: 'Heel R', group: 'Feet' },
                'heel02R_metarig': { friendlyName: 'Heel Top R', group: 'Feet' },
            },
            'models/game_character_base.glb': {
                // Rigging
                'Rig001_rootJoint': { friendlyName: 'Root', group: 'Root' },
                'ikr_Rig001': { friendlyName: 'IK Right Leg', group: 'Rigging' },
                'kneer_Rig001': { friendlyName: 'Knee Target R', group: 'Rigging' },
                'ikl_Rig001': { friendlyName: 'IK Left Leg', group: 'Rigging' },
                'kneel_Rig001': { friendlyName: 'Knee Target L', group: 'Rigging' },
                // Torso
                'spine_Rig001': { friendlyName: 'Spine Base', group: 'Torso' },
                'spine001_Rig001': { friendlyName: 'Spine 1', group: 'Torso' },
                'spine002_Rig001': { friendlyName: 'Spine 2', group: 'Torso' },
                'spine003_Rig001': { friendlyName: 'Spine 3', group: 'Torso' },
                'spine004_Rig001': { friendlyName: 'Spine 4 (Chest)', group: 'Torso' },
                'breastL_Rig001': { friendlyName: 'Breast L', group: 'Torso' },
                'breastR_Rig001': { friendlyName: 'Breast R', group: 'Torso' },
                // Head
                'spine006_Rig001': { friendlyName: 'Head', group: 'Head' }, // Assuming this is head based on hierarchy
                'lidTL_Rig001': { friendlyName: 'Eyelid Top L', group: 'Head', subGroup: 'Face' },
                'lidBL001_Rig001': { friendlyName: 'Eyelid Bottom L', group: 'Head', subGroup: 'Face' },
                'lidTR_Rig001': { friendlyName: 'Eyelid Top R', group: 'Head', subGroup: 'Face' },
                'lidBR001_Rig001': { friendlyName: 'Eyelid Bottom R', group: 'Head', subGroup: 'Face' },
                'eyeL_Rig001': { friendlyName: 'Eye L', group: 'Head', subGroup: 'Face' },
                'eyeR_Rig001': { friendlyName: 'Eye R', group: 'Head', subGroup: 'Face' },
                'jaw_Rig001': { friendlyName: 'Jaw', group: 'Head', subGroup: 'Face' },
                // Left Arm
                'shoulderL_Rig001': { friendlyName: 'Shoulder L', group: 'Arms' },
                'upper_armL_Rig001': { friendlyName: 'Upper Arm L', group: 'Arms' },
                'forearmL_Rig001': { friendlyName: 'Forearm L', group: 'Arms' },
                'handL_Rig001': { friendlyName: 'Hand L', group: 'Hands', subGroup: '_root' },
                // Left Hand
                'palm01L_Rig001': { friendlyName: 'Palm Index L', group: 'Hands', subGroup: 'Left Palm' },
                'f_index01L_Rig001': { friendlyName: 'Index 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index02L_Rig001': { friendlyName: 'Index 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_index03L_Rig001': { friendlyName: 'Index 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb01L_Rig001': { friendlyName: 'Thumb 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb02L_Rig001': { friendlyName: 'Thumb 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'thumb03L_Rig001': { friendlyName: 'Thumb 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm02L_Rig001': { friendlyName: 'Palm Middle L', group: 'Hands', subGroup: 'Left Palm' },
                'f_middle01L_Rig001': { friendlyName: 'Middle 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle02L_Rig001': { friendlyName: 'Middle 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_middle03L_Rig001': { friendlyName: 'Middle 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm03L_Rig001': { friendlyName: 'Palm Ring L', group: 'Hands', subGroup: 'Left Palm' },
                'f_ring01L_Rig001': { friendlyName: 'Ring 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring02L_Rig001': { friendlyName: 'Ring 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_ring03L_Rig001': { friendlyName: 'Ring 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                'palm04L_Rig001': { friendlyName: 'Palm Pinky L', group: 'Hands', subGroup: 'Left Palm' },
                'f_pinky01L_Rig001': { friendlyName: 'Pinky 1 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky02L_Rig001': { friendlyName: 'Pinky 2 L', group: 'Hands', subGroup: 'Left Fingers' },
                'f_pinky03L_Rig001': { friendlyName: 'Pinky 3 L', group: 'Hands', subGroup: 'Left Fingers' },
                // Right Arm
                'shoulderR_Rig001': { friendlyName: 'Shoulder R', group: 'Arms' },
                'upper_armR_Rig001': { friendlyName: 'Upper Arm R', group: 'Arms' },
                'forearmR_Rig001': { friendlyName: 'Forearm R', group: 'Arms' },
                'handR_Rig001': { friendlyName: 'Hand R', group: 'Hands', subGroup: '_root' },
                // Right Hand
                'palm01R_Rig001': { friendlyName: 'Palm Index R', group: 'Hands', subGroup: 'Right Palm' },
                'f_index01R_Rig001': { friendlyName: 'Index 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index02R_Rig001': { friendlyName: 'Index 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_index03R_Rig001': { friendlyName: 'Index 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb01R_Rig001': { friendlyName: 'Thumb 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb02R_Rig001': { friendlyName: 'Thumb 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'thumb03R_Rig001': { friendlyName: 'Thumb 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm02R_Rig001': { friendlyName: 'Palm Middle R', group: 'Hands', subGroup: 'Right Palm' },
                'f_middle01R_Rig001': { friendlyName: 'Middle 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle02R_Rig001': { friendlyName: 'Middle 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_middle03R_Rig001': { friendlyName: 'Middle 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm03R_Rig001': { friendlyName: 'Palm Ring R', group: 'Hands', subGroup: 'Right Palm' },
                'f_ring01R_Rig001': { friendlyName: 'Ring 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring02R_Rig001': { friendlyName: 'Ring 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_ring03R_Rig001': { friendlyName: 'Ring 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                'palm04R_Rig001': { friendlyName: 'Palm Pinky R', group: 'Hands', subGroup: 'Right Palm' },
                'f_pinky01R_Rig001': { friendlyName: 'Pinky 1 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky02R_Rig001': { friendlyName: 'Pinky 2 R', group: 'Hands', subGroup: 'Right Fingers' },
                'f_pinky03R_Rig001': { friendlyName: 'Pinky 3 R', group: 'Hands', subGroup: 'Right Fingers' },
                // Left Leg
                'pelvisL_Rig001': { friendlyName: 'Pelvis L', group: 'Legs' },
                'thighL_Rig001': { friendlyName: 'Thigh L', group: 'Legs' },
                'shinL_Rig001': { friendlyName: 'Shin L', group: 'Legs' },
                'footL_Rig001': { friendlyName: 'Foot L', group: 'Feet' },
                'toeL_Rig001': { friendlyName: 'Toe L', group: 'Feet' },
                'heel02L_Rig001': { friendlyName: 'Heel L', group: 'Feet' },
                // Right Leg
                'pelvisR_Rig001': { friendlyName: 'Pelvis R', group: 'Legs' },
                'thighR_Rig001': { friendlyName: 'Thigh R', group: 'Legs' },
                'shinR_Rig001': { friendlyName: 'Shin R', group: 'Legs' },
                'footR_Rig001': { friendlyName: 'Foot R', group: 'Feet' },
                'toeR_Rig001': { friendlyName: 'Toe R', group: 'Feet' },
                'heel02R_Rig001': { friendlyName: 'Heel R', group: 'Feet' },
            },
            // Add entries for any other models you might load
        };
        // --- END Bone Mapping Configuration ---


        // --- Initialization ---
        init();
        animate();

        // --- Functions ---

        function updateTransformButtonStyles() {
            const currentMode = transformControls.mode;
            document.querySelectorAll('.transform-btn').forEach(btn => {
                if (btn.dataset.mode === currentMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            console.log(`Transform mode set to: ${currentMode}`);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); // Darker background

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(2, 2, 2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.5; // Prevent zooming too close
            controls.maxDistance = 50; // Prevent zooming too far

            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value; // Disable orbit controls while dragging
            });
            transformControls.addEventListener('mouseUp', function (event) {
                if (selectedBone) {
                    console.log("Transform mouseUp detected, saving state.");
                    saveHistoryState(); // Save state after transform interaction ends
                }
            });
            transformControls.addEventListener('mode-changed', updateTransformButtonStyles);
            scene.add(transformControls);

            addLighting();

            // Grid Helper (Floor)
            gridHelper = new THREE.GridHelper(40, 40, 0x888888, 0x444444); // Lighter grid lines
            gridHelper.position.y = 0; // Ensure it's at floor level
            scene.add(gridHelper);

            // Wireframe Material
            wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, side: THREE.DoubleSide });

            // Event Listeners
            savePoseDataBtn.addEventListener('click', savePoseDataLocally);
            wireframeButton.addEventListener('click', toggleWireframe);
            undoButton.addEventListener('click', undo);
            redoButton.addEventListener('click', redo);
            refreshModelButton.addEventListener('click', refreshModel);
            backToShadowRoomBtn.addEventListener('click', () => window.close()); // Consider providing feedback or confirmation

            // Transform Controls Buttons
            document.getElementById('translateButton').addEventListener('click', () => transformControls.setMode('translate'));
            document.getElementById('rotateButton').addEventListener('click', () => transformControls.setMode('rotate'));
            detachButton.addEventListener('click', () => { // Use the correct variable name
                transformControls.detach();
                selectedBone = null;
                const selectedListItem = boneListContainer.querySelector('li.selected');
                if (selectedListItem) selectedListItem.classList.remove('selected');
                console.log('Transform controls detached.');
                // Reset camera target to model center when detaching
                controls.target.copy(modelCenter);
                controls.update();
            });


            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', handleKeyDown);

            // Load model from URL parameter
            loadModelFromUrlParam();

            // Set initial transform mode and update button style
            transformControls.setMode('translate');
            updateTransformButtonStyles();
        }

        function loadModelFromUrlParam() {
            const params = new URLSearchParams(window.location.search);
            const modelToLoad = params.get('model');
            if (modelToLoad) {
                const decodedPath = decodeURIComponent(modelToLoad);
                console.log(`Model path found in URL: ${decodedPath}`);
                originalModelPath = decodedPath; // Store for refresh and mapping
                loadSelectedModel(decodedPath);
            } else {
                console.error("No model specified in URL parameter. Cannot load model.");
                setInfo('Error: No model specified in the URL. Please open from Shadow Room.', 'error');
                // Disable buttons if no model can be loaded
                savePoseDataBtn.disabled = true;
                wireframeButton.disabled = true;
                undoButton.disabled = true;
                redoButton.disabled = true;
                refreshModelButton.disabled = true;
                transformModeControls.style.display = 'none';
            }
        }

        function addLighting() {
            // Ambient Light
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Slightly brighter ambient
            scene.add(ambientLight);

            // Directional Light (Sun)
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Stronger directional
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            // Configure shadow properties for better quality
            directionalLight.shadow.mapSize.width = 2048; // Higher resolution shadow map
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            // Adjust shadow camera bounds if needed based on scene size
            directionalLight.shadow.camera.left = -15;
            directionalLight.shadow.camera.right = 15;
            directionalLight.shadow.camera.top = 15;
            directionalLight.shadow.camera.bottom = -15;
            directionalLight.shadow.bias = -0.0005; // Adjust shadow bias to prevent artifacts

            scene.add(directionalLight);

            // Optional: Add a hemisphere light for softer fill
            // const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.4 );
            // hemiLight.position.set( 0, 20, 0 );
            // scene.add( hemiLight );
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Required if damping or auto-rotate is enabled
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            if (!container || !camera || !renderer) return; // Check if elements exist
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Ensure width and height are positive before resizing
            if (width > 0 && height > 0) {
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        function clearScene() {
            // Detach controls first
            transformControls.detach();

            // Remove model group and dispose resources
            if (loadedModelGroup) {
                scene.remove(loadedModelGroup);
                // Dispose geometry and materials
                loadedModelGroup.traverse(child => {
                    if (child.isMesh) {
                        child.geometry?.dispose();
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m?.dispose());
                        } else {
                            child.material?.dispose();
                        }
                    }
                });
                console.log("Previous model removed and resources disposed.");
            }

            // Reset state variables
            loadedModelGroup = null;
            bones.length = 0;
            selectedBone = null;
            history = [];
            historyIndex = -1;
            initialBoneState = [];
            originalMaterials.clear();
            wireframeActive = false; // Reset wireframe state
            updateUndoRedoButtons();
            console.log("History and wireframe state cleared.");

            // Clear UI elements
            meshListElement.innerHTML = '';
            boneListContainer.innerHTML = ''; // Clear the container directly
            // No need to re-get boneListElement, populateBoneList will recreate content
            materialListElement.innerHTML = '';
            animationListElement.innerHTML = '';
            summaryElement.innerHTML = '';
            componentsInfoElement.style.display = 'none'; // Hide panel
        }


        function loadSelectedModel(modelPath) {
             clearScene(); // Clear everything before loading
             setInfo(`Loading ${modelPath}...`, 'loading');
             componentsInfoElement.style.display = 'none'; // Hide panel during load

             // Disable buttons during load
             savePoseDataBtn.disabled = true;
             transformModeControls.style.display = 'none';
             transformControls.detach();
             wireframeButton.disabled = true;
             undoButton.disabled = true;
             redoButton.disabled = true;
             refreshModelButton.disabled = true;

             fetch(modelPath)
                 .then(response => {
                     if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status} for ${modelPath}`);
                     }
                     return response.arrayBuffer();
                 })
                 .then(buffer => {
                     // Pass the filename (last part of path) to loadGLB
                     loadGLB(buffer, modelPath.split('/').pop());
                 })
                 .catch(error => {
                     console.error('Error fetching or loading model:', error);
                     setInfo(`Error loading ${modelPath}: ${error.message}`, 'error');
                     clearScene(); // Ensure scene is cleared on error
                 });
        }

        function loadGLB(data, filename) {
            const loader = new GLTFLoader();
            loader.parse(data, '', (gltf) => {
                // Don't clear scene here, clearScene was called in loadSelectedModel
                loadedModelGroup = gltf.scene;
                loadedModelGroup.animations = gltf.animations; // Store animations if any

                // --- Calculate bounding box and scale ---
                const box = new THREE.Box3().setFromObject(loadedModelGroup);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = maxDim > 0 ? 2.0 / maxDim : 1.0;

                // --- Apply scale first ---
                loadedModelGroup.scale.set(scale, scale, scale);
                loadedModelGroup.updateMatrixWorld(true);

                // --- Recalculate bounding box AFTER scaling ---
                const scaledBox = new THREE.Box3().setFromObject(loadedModelGroup);
                const scaledCenter = scaledBox.getCenter(new THREE.Vector3());
                const scaledBottomY = scaledBox.min.y;

                // --- Adjust position ---
                loadedModelGroup.position.set(
                    -scaledCenter.x,
                    -scaledBottomY,
                    -scaledCenter.z
                );
                // --- End Position Adjustment ---

                // --- Store the final center and set initial camera target ---
                modelCenter.set(0, scaledBox.getSize(new THREE.Vector3()).y / 2, 0);
                modelCenter.add(loadedModelGroup.position); // Add group's position for world center

                controls.target.copy(modelCenter); // Set initial target
                controls.update();
                // --- END ADD ---

                // Traverse and setup meshes/bones
                loadedModelGroup.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Store original material for wireframe toggle
                        originalMaterials.set(child, child.material);
                    }
                    // Bones are collected in populateComponentsInfo
                });

                scene.add(loadedModelGroup);

                // Populate info panel AFTER adding to scene
                populateComponentsInfo(gltf, filename);

                setInfo(`Loaded ${filename}`, 'success');

                // Enable buttons now that model is loaded
                savePoseDataBtn.disabled = false;
                wireframeButton.disabled = false;
                refreshModelButton.disabled = false;
                transformModeControls.style.display = 'flex'; // Show transform controls

                // Save initial state for history/refresh
                saveInitialState();
                saveHistoryState(); // Save the very first state

            }, (error) => {
                console.error('Error parsing GLB:', error);
                setInfo(`Error parsing ${filename}: ${error.message || error}`, 'error');
                clearScene(); // Ensure scene is cleared on parsing error
            });
        }

        function populateComponentsInfo(gltf, filename) {
            // Clear previous lists (ensure containers are empty)
            meshListElement.innerHTML = '';
            boneListContainer.innerHTML = ''; // Clear bone container
            materialListElement.innerHTML = '';
            animationListElement.innerHTML = '';
            bones.length = 0; // Clear the bones array

            let meshCount = 0;
            let materialCount = 0;
            const uniqueMaterials = new Set();

            // Traverse the loaded scene to find meshes, bones, materials
            gltf.scene.traverse((child) => {
                if (child.isMesh) {
                    meshCount++;
                    const li = document.createElement('li');
                    li.textContent = child.name || `Mesh ${meshCount}`;
                    meshListElement.appendChild(li);

                    // Collect unique materials
                    if (child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => uniqueMaterials.add(mat));
                    }
                }
                if (child.isBone) {
                    bones.push(child); // Collect bone objects
                }
            });

            // Populate material list
            uniqueMaterials.forEach((mat) => {
                materialCount++;
                const li = document.createElement('li');
                li.textContent = mat.name || `Material ${materialCount}`;
                materialListElement.appendChild(li);
            });

            // Populate bone list using the new structure
            populateBoneList(); // This function now handles its own container clearing

            // Populate animation list
            if (gltf.animations && gltf.animations.length > 0) {
                gltf.animations.forEach((clip) => {
                    const li = document.createElement('li');
                    li.textContent = clip.name || 'Animation Clip';
                    animationListElement.appendChild(li);
                });
            } else {
                animationListElement.innerHTML = '<li>No animations found</li>';
            }

            // Update summary information
            summaryElement.innerHTML = `
                <strong>Filename:</strong> ${filename}<br>
                <strong>Bones:</strong> ${bones.length}
            `;

            // Show the components panel
            componentsInfoElement.style.display = 'block';
        }

        function populateBoneList() {
            boneListContainer.innerHTML = ''; // Clear previous content first

            // Use originalModelPath which should be set when loading
            const modelMapping = boneMappingConfig[originalModelPath];

            if (!modelMapping) {
                console.warn(`No bone mapping found for model: ${originalModelPath}. Displaying raw names.`);
                // Fallback: Display raw names without grouping
                const ul = document.createElement('ul');
                bones.forEach(bone => {
                    const li = createAndAttachListItem({
                         bone: bone,
                         friendlyName: bone.name || 'Unnamed Bone'
                    });
                    ul.appendChild(li);
                });
                boneListContainer.appendChild(ul);
                return;
            }

            // --- Grouping Logic ---
            const groupedBones = {}; // { groupName: { subGroupName: [boneInfo], _root: [boneInfo] } }
            // Define display order for groups
            const groupOrder = ['Root', 'Rigging', 'Head', 'Torso', 'Arms', 'Hands', 'Legs', 'Feet', 'Other'];

            bones.forEach(bone => {
                const mappingInfo = modelMapping[bone.name];
                const boneInfo = {
                    bone: bone,
                    friendlyName: mappingInfo?.friendlyName || bone.name || 'Unnamed Bone',
                    group: mappingInfo?.group || 'Other',
                    subGroup: mappingInfo?.subGroup // Can be undefined, e.g., '_root' or specific like 'Left Fingers'
                };

                // Initialize group if it doesn't exist
                if (!groupedBones[boneInfo.group]) {
                    groupedBones[boneInfo.group] = { _root: [] }; // _root holds bones directly in this group
                }

                // Decide where to put the bone: subgroup or group's root
                const targetSubGroup = boneInfo.subGroup && boneInfo.subGroup !== '_root' ? boneInfo.subGroup : '_root';

                // Initialize subGroup/root array if it doesn't exist
                if (!groupedBones[boneInfo.group][targetSubGroup]) {
                    groupedBones[boneInfo.group][targetSubGroup] = [];
                }
                groupedBones[boneInfo.group][targetSubGroup].push(boneInfo);
            });

            // --- HTML Generation ---
            groupOrder.forEach(groupName => {
                const groupData = groupedBones[groupName];
                if (!groupData) return; // Skip if group is empty for this model

                const groupDetails = document.createElement('details');
                // Keep major groups open initially, close hands/feet/rigging/other
                groupDetails.open = !['Hands', 'Feet', 'Rigging', 'Other'].includes(groupName);

                const groupSummary = document.createElement('summary');
                groupSummary.textContent = groupName;
                groupDetails.appendChild(groupSummary);

                const groupUl = document.createElement('ul');

                // Add bones directly under the main group first (from _root)
                groupData._root.forEach(boneInfo => {
                    const li = createAndAttachListItem(boneInfo);
                    groupUl.appendChild(li);
                });

                // Add sub-groups (like fingers, palms, face)
                Object.keys(groupData).sort().forEach(subGroupName => { // Sort subgroups alphabetically
                    if (subGroupName === '_root') return; // Skip the root list we already processed

                    const subGroupDetails = document.createElement('details');
                    subGroupDetails.open = false; // Keep subgroups closed initially

                    const subGroupSummary = document.createElement('summary');
                    subGroupSummary.textContent = subGroupName;
                    subGroupDetails.appendChild(subGroupSummary);

                    const subGroupUl = document.createElement('ul');
                    groupData[subGroupName].forEach(boneInfo => {
                        const li = createAndAttachListItem(boneInfo);
                        subGroupUl.appendChild(li);
                    });
                    subGroupDetails.appendChild(subGroupUl);
                    groupUl.appendChild(subGroupDetails); // Add subgroup details to main group ul
                });

                groupDetails.appendChild(groupUl);
                boneListContainer.appendChild(groupDetails);
            });

             // Helper to create LI and attach listener
             function createAndAttachListItem(boneInfo) {
                 const li = document.createElement('li');
                 li.textContent = boneInfo.friendlyName;
                 li.dataset.boneName = boneInfo.bone.name; // Store original name for lookup
                 li.addEventListener('click', handleBoneClick);
                 return li;
             }
        }

        // Shared click handler for bone list items
        function handleBoneClick(event) {
            const li = event.currentTarget;
            const boneName = li.dataset.boneName;
            const targetBone = bones.find(b => b.name === boneName);

            if (!targetBone) {
                console.error(`Could not find bone object for name: ${boneName}`);
                return;
            }

            // Deselect previous
            const currentlySelected = boneListContainer.querySelector('li.selected');
            if (currentlySelected) currentlySelected.classList.remove('selected');

            // Select current
            li.classList.add('selected');
            selectedBone = targetBone;
            transformControls.attach(targetBone); // Attach controls to the clicked bone
            console.log(`Selected bone: ${targetBone.name} (Friendly: ${li.textContent})`);

            // --- Camera Focus ---
            const boneWorldPosition = new THREE.Vector3();
            targetBone.getWorldPosition(boneWorldPosition);
            controls.target.copy(boneWorldPosition);
            controls.update();
            // --- END Camera Focus ---
        }

        function toggleWireframe() {
            if (!loadedModelGroup) return;
            wireframeActive = !wireframeActive;
            loadedModelGroup.traverse((child) => {
                if (child.isMesh) {
                    if (wireframeActive) {
                        // Ensure original material is stored before switching
                        if (!originalMaterials.has(child)) {
                            originalMaterials.set(child, child.material);
                        }
                        child.material = wireframeMaterial;
                    } else {
                        // Restore original material if it exists
                        if (originalMaterials.has(child)) {
                            child.material = originalMaterials.get(child);
                        }
                    }
                }
            });
            console.log(`Wireframe ${wireframeActive ? 'enabled' : 'disabled'}`);
        }

        function saveInitialState() {
            // Save the initial state of all bones
            initialBoneState = bones.map(bone => ({
                name: bone.name,
                position: bone.position.clone(),
                quaternion: bone.quaternion.clone(),
                scale: bone.scale.clone()
            }));
            console.log("Initial bone state saved.");
        }

        function refreshModel() {
            if (!originalModelPath) {
                setInfo("Cannot refresh: Original model path not known.", "error");
                return;
            }
            setInfo(`Refreshing model to initial state: ${originalModelPath}`, 'loading');
            // Simply reload the model using the stored path
            loadSelectedModel(originalModelPath);
        }

        function saveHistoryState() {
            if (!loadedModelGroup || bones.length === 0) return; // Don't save if no model/bones

            const currentState = bones.map(bone => ({
                name: bone.name,
                position: bone.position.clone(),
                quaternion: bone.quaternion.clone(),
                scale: bone.scale.clone()
            }));

            // If we undid, truncate future history before adding new state
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            // Add the new state
            history.push(currentState);

            // Limit history size
            if (history.length > MAX_HISTORY) {
                history.shift(); // Remove the oldest state
            }

            // Update the index to point to the newly added state
            historyIndex = history.length - 1;


            console.log(`History state saved. Index: ${historyIndex}, Size: ${history.length}`);
            updateUndoRedoButtons();
        }

        function applyHistoryState(stateIndex) {
            if (stateIndex < 0 || stateIndex >= history.length) {
                console.warn(`Invalid history index: ${stateIndex}`);
                return;
            }

            const stateToApply = history[stateIndex];
            let boneFound = false; // Flag to check if any bone was actually updated

            stateToApply.forEach(boneState => {
                const bone = bones.find(b => b.name === boneState.name);
                if (bone) {
                    bone.position.copy(boneState.position);
                    bone.quaternion.copy(boneState.quaternion);
                    bone.scale.copy(boneState.scale);
                    // No need to update matrix world here, skeleton update handles it
                    boneFound = true;
                } else {
                    console.warn(`Bone not found during history apply: ${boneState.name}`);
                }
            });

            // Update the skeleton helper if the model has one
            if (boneFound && loadedModelGroup) {
                 loadedModelGroup.traverse(obj => {
                      // Update skeleton for skinned meshes
                      if (obj.isSkinnedMesh) {
                           obj.skeleton.update();
                      }
                      // Also force update world matrix for the whole hierarchy just in case
                      obj.updateMatrixWorld(true);
                 });
            }

            historyIndex = stateIndex;
            console.log(`Applied history state at index: ${historyIndex}`);
            updateUndoRedoButtons();

            // Re-attach transform controls if a bone was selected
            if (selectedBone && transformControls.object !== selectedBone) {
                 transformControls.attach(selectedBone);
            } else if (!selectedBone && transformControls.object) {
                 // Detach if no bone should be selected
                 transformControls.detach();
            }

            // Update camera target if a bone is selected
            if (selectedBone) {
                const boneWorldPosition = new THREE.Vector3();
                selectedBone.getWorldPosition(boneWorldPosition);
                controls.target.copy(boneWorldPosition);
                controls.update();
            } else {
                // Reset to model center if no bone selected
                controls.target.copy(modelCenter);
                controls.update();
            }
        }

        function undo() {
            if (historyIndex > 0) {
                applyHistoryState(historyIndex - 1);
            } else {
                console.log("Cannot undo: At initial state.");
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                applyHistoryState(historyIndex + 1);
            } else {
                console.log("Cannot redo: At latest state.");
            }
        }

        function updateUndoRedoButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = historyIndex >= history.length - 1;
        }

        function handleKeyDown(event) {
            // Ignore key events if focused on an input/select/button etc.
            if (document.activeElement && ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                return;
            }

            const isCtrlOrCmd = event.ctrlKey || event.metaKey; // Handle Cmd on Mac

            if (isCtrlOrCmd && event.key.toLowerCase() === 'z') {
                event.preventDefault();
                undo();
            } else if (isCtrlOrCmd && event.key.toLowerCase() === 'y') {
                event.preventDefault();
                redo();
            } else if (event.key.toLowerCase() === 't') { // Shortcut for Translate
                 event.preventDefault();
                 transformControls.setMode('translate');
            } else if (event.key.toLowerCase() === 'r') { // Shortcut for Rotate
                 event.preventDefault();
                 transformControls.setMode('rotate');
            } else if (event.key === 'Escape') { // Shortcut for Detach
                 event.preventDefault();
                 detachButton.click(); // Simulate click on detach button
            }
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function savePoseDataLocally() {
            if (!loadedModelGroup || !originalModelPath || bones.length === 0) {
                console.warn('Model/path missing or no bones found.');
                setInfo('Load a model with bones before saving pose data.', 'error');
                return;
            }

            // 1. Prompt for a pose name
            const poseName = prompt("Enter a name for this pose:", "New Pose");

            // 2. Validate the name
            if (!poseName || poseName.trim() === "") {
                setInfo('Save cancelled: No pose name provided.', 'info');
                console.log('Pose save cancelled by user or empty name.');
                return;
            }
            const trimmedPoseName = poseName.trim(); // Use trimmed name

            setInfo(`Saving pose "${trimmedPoseName}"...`, 'loading');

            try {
                // 3. Extract current pose data
                const currentPoseData = bones.map(bone => ({
                    name: bone.name,
                    position: bone.position.toArray(),
                    quaternion: bone.quaternion.toArray(),
                    scale: bone.scale.toArray()
                }));

                // 4. Get existing poses for this model
                const storageKey = `poses_${originalModelPath}`;
                let existingPoses = {};
                const storedData = localStorage.getItem(storageKey);
                if (storedData) {
                    try {
                        existingPoses = JSON.parse(storedData);
                        // Basic check if it's an object
                        if (typeof existingPoses !== 'object' || existingPoses === null) {
                            console.warn(`Invalid data found in localStorage for key ${storageKey}. Resetting.`);
                            existingPoses = {};
                        }
                    } catch (parseError) {
                        console.error(`Error parsing existing pose data for ${storageKey}:`, parseError);
                        setInfo(`Error reading previous poses. Overwriting may occur. ${parseError.message}`, 'error');
                        existingPoses = {}; // Reset on parse error
                    }
                }

                // 5. Add or update the new pose data under the given name
                existingPoses[trimmedPoseName] = currentPoseData;

                // 6. Save the updated poses object back to localStorage
                const updatedPosesString = JSON.stringify(existingPoses);
                localStorage.setItem(storageKey, updatedPosesString);

                setInfo(`Pose "${trimmedPoseName}" saved locally. Close tab and refresh poses in Shadow Room.`, 'success');
                console.log(`Pose "${trimmedPoseName}" saved to localStorage key: ${storageKey}`);
                console.log(`Total stored data size for this model: ${updatedPosesString.length} bytes`);

            } catch (saveError) {
                console.error('Error saving pose data to localStorage:', saveError);
                setInfo(`Save failed: ${saveError.message}`, 'error');
            }
        }

        function setInfo(message, type = 'info') {
            if (!infoElement) return; // Check if element exists
            infoElement.textContent = message;
            // Apply class based on type for styling
            infoElement.className = type; // Assumes CSS rules for .info, .error, .success, .loading
        }

    </script>

</body>
</html>
