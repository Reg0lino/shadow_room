<!DOCTYPE html>
<html>
<head>
    <title>Model Poser Tool</title>
    <link rel="stylesheet" href="css/poser_style.css">
</head>
<body>
    <div id="wrapper">
        <!-- Controls Bar -->
        <div id="controls">
            <!-- Group 1: Transform Controls -->
            <div id="transformModeControls" class="controls-group" style="display: none;">
                <span>Transform:</span>
                <button id="rotateButton" class="transform-btn active" data-mode="rotate">Rotate</button>
                <button id="translateButton" class="transform-btn" data-mode="translate">Translate</button>
                <button id="detachButton" title="Detach Transform Controls">Detach</button>
            </div>
            <!-- Group 2: Main Buttons -->
            <div class="controls-group">
                <label for="modelSelect">Model:</label>
                <select id="modelSelect" style="display: none;"><option value="" disabled selected>-- Select Model --</option></select>
                <button id="refreshModelButton" disabled title="Reload original model state">Refresh</button>
                <button id="savePoseDataBtn" disabled>Save Pose Data</button>
                <input type="file" id="loadPoseFileInput" accept=".json" style="display: none;" />
                <button id="loadPoseFileBtn" disabled>Load Pose File</button>
                <button id="wireframeButton" disabled>Toggle Wireframe</button>
                <button id="undoButton" disabled title="Undo (Ctrl+Z)">Undo</button>
                <button id="redoButton" disabled title="Redo (Ctrl+Y)">Redo</button>
                <button id="backToShadowRoomBtn">Back to Shadow Room</button>
                <button id="toggleDebugBtn" title="Toggle Debug Panel (D)">D</button>
            </div>
        </div>

        <!-- Container (Canvas Area) -->
        <div id="container">
            <div id="info">Load a GLB file</div>
        </div>

        <!-- Components Info Panel -->
        <div id="componentsInfo" style="display: none;">
            <h3>Model Components</h3>
            <div id="summary"></div>
            <h4>Bones</h4> <div id="boneListContainer"></div>
            <details><summary><h4>Meshes</h4></summary><ul id="meshList"></ul></details>
            <details><summary><h4>Materials</h4></summary><ul id="materialList"></ul></details>
            <details><summary><h4>Animations</h4></summary><ul id="animationList"></ul></details>
        </div>

        <!-- <<< Debug Panel >>> -->
        <div id="debugPanel" style="display: none;">
            <!-- <<< Added Header Div for Button >>> -->
            <div class="debug-header">
                 <h3>Bone Debug Info</h3>
                 <button id="saveDebugDataBtn">Save Data</button>
            </div>
            <div id="debugBoneListContainer">
                <!-- Content generated by JS -->
            </div>
        </div>
        <!-- <<< End Debug Panel >>> -->

    </div> <!-- End #wrapper -->

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/" } }
    </script>

    <script type="module">
        // --- Imports ---
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Global Variables ---
        // ... (same as before) ...
        let scene, camera, renderer, controls, transformControls;
        let ambientLight, directionalLight, gridHelper, wireframeMaterial;
        let originalModelPath = ''; let wireframeActive = false; let selectedBone = null;
        const originalMaterials = new Map(); let loadedModelGroup = null;
        let modelCenter = new THREE.Vector3(0, 0, 0); const bones = [];
        const MAX_HISTORY = 50; let history = []; let historyIndex = -1; let initialBoneState = [];
        let loadedBoneMappings = null; let boneMappingPromise = null;


        // --- DOM Element References ---
        // ... (same as before) ...
        const container = document.getElementById('container'); const infoElement = document.getElementById('info');
        const componentsInfoElement = document.getElementById('componentsInfo'); const summaryElement = document.getElementById('summary');
        const meshListElement = document.getElementById('meshList'); const boneListContainer = document.getElementById('boneListContainer');
        let boneListElement = document.getElementById('boneList'); const materialListElement = document.getElementById('materialList');
        const animationListElement = document.getElementById('animationList'); const savePoseDataBtn = document.getElementById('savePoseDataBtn');
        const transformModeControls = document.getElementById('transformModeControls'); const detachButton = document.getElementById('detachButton');
        const wireframeButton = document.getElementById('wireframeButton'); const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton'); const refreshModelButton = document.getElementById('refreshModelButton');
        const backToShadowRoomBtn = document.getElementById('backToShadowRoomBtn');
        const loadPoseFileInput = document.getElementById('loadPoseFileInput'); const loadPoseFileBtn = document.getElementById('loadPoseFileBtn');
        const debugPanel = document.getElementById('debugPanel'); const debugBoneListContainer = document.getElementById('debugBoneListContainer');
        const toggleDebugBtn = document.getElementById('toggleDebugBtn');
        // <<< Add ref for save debug button >>>
        const saveDebugDataBtn = document.getElementById('saveDebugDataBtn');

        // --- Logging ---
        function logToPage(message, type = 'info') { console[type === 'error' ? 'error' : type === 'warn' ? 'warn' : 'log'](`[${new Date().toLocaleTimeString()}] ${message}`); }

        // --- Function Definitions (Order Matters!) ---

        async function loadBoneMappings() { /* ... definition ... */ logToPage("Attempting to load bone mappings from JSON..."); try { const r = await fetch('js/bone_mappings.json'); if (!r.ok) throw new Error(`HTTP error! status: ${r.status}`); loadedBoneMappings = await r.json(); logToPage("Bone mappings loaded successfully.", "success"); return loadedBoneMappings; } catch (error) { logToPage(`Failed to load or parse bone mappings: ${error.message}`, "error"); console.error("Bone Mapping Load Error:", error); loadedBoneMappings = {}; return {}; } }
        function onWindowResize() { /* ... definition ... */ if (!container || !camera || !renderer) return; const w = container.clientWidth; const h = container.clientHeight; if (w > 0 && h > 0) { camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); } else { logToPage(`Resize ignored: Invalid container dimensions ${w}x${h}`, "warn"); } }
        function addLighting() { /* ... definition ... */ ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight); directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(5, 10, 7.5); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; directionalLight.shadow.camera.left = -15; directionalLight.shadow.camera.right = 15; directionalLight.shadow.camera.top = 15; directionalLight.shadow.camera.bottom = -15; directionalLight.shadow.bias = -0.0005; scene.add(directionalLight); logToPage("Poser lighting added."); }
        function updateTransformButtonStyles() { /* ... definition ... */ if (!transformControls) return; const mode = transformControls.mode; document.querySelectorAll('.transform-btn').forEach(btn => { btn.classList.toggle('active', btn.dataset.mode === mode); }); }
        function clearScene() { /* ... definition ... */ transformControls.detach(); if (loadedModelGroup) { scene.remove(loadedModelGroup); loadedModelGroup.traverse(child => { if (child.isMesh) { child.geometry?.dispose(); const materials = Array.isArray(child.material) ? child.material : [child.material]; materials.forEach(m => m?.dispose()); } }); } loadedModelGroup = null; bones.length = 0; selectedBone = null; history = []; historyIndex = -1; initialBoneState = []; originalMaterials.clear(); wireframeActive = false; updateUndoRedoButtons(); meshListElement.innerHTML = ''; boneListContainer.innerHTML = ''; materialListElement.innerHTML = ''; animationListElement.innerHTML = ''; summaryElement.innerHTML = ''; if(loadPoseFileBtn) loadPoseFileBtn.disabled = true; clearDebugPanelContent(); logToPage("Scene cleared.", "info"); }
        async function loadSelectedModel(modelPath) { /* ... definition ... */ logToPage(`loadSelectedModel called for: ${modelPath}`); clearScene(); setInfo(`Loading ${modelPath}...`, 'loading'); componentsInfoElement.style.display = 'none'; savePoseDataBtn.disabled = true; if(transformModeControls) transformModeControls.style.display = 'none'; wireframeButton.disabled = true; undoButton.disabled = true; redoButton.disabled = true; refreshModelButton.disabled = true; try { const response = await fetch(modelPath); if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${modelPath}`); const buffer = await response.arrayBuffer(); logToPage("Model data fetched."); await loadGLB(buffer, modelPath.split('/').pop()); } catch (error) { console.error('Error in loadSelectedModel:', error); logToPage(`Error loading ${modelPath}: ${error.message}`, 'error'); setInfo(`Error loading ${modelPath}`, 'error'); clearScene(); } }
        async function loadGLB(data, filename) { /* ... definition ... */ logToPage(`loadGLB called for: ${filename}`); const loader = new GLTFLoader(); return new Promise((resolve, reject) => { loader.parse(data, '', async (gltf) => { logToPage("GLB parsed."); try { loadedModelGroup = gltf.scene; loadedModelGroup.animations = gltf.animations; const box=new THREE.Box3().setFromObject(loadedModelGroup); const size=box.getSize(new THREE.Vector3()); const maxDim=Math.max(size.x,size.y,size.z); const scale=maxDim>0?2.0/maxDim:1.0; loadedModelGroup.scale.set(scale,scale,scale); loadedModelGroup.updateMatrixWorld(true); const sBox=new THREE.Box3().setFromObject(loadedModelGroup); const sCenter=sBox.getCenter(new THREE.Vector3()); const sBottomY=sBox.min.y; loadedModelGroup.position.set(-sCenter.x,-sBottomY,-sCenter.z); logToPage("Model scaled and positioned."); modelCenter.set(0, sBox.getSize(new THREE.Vector3()).y / 2, 0); modelCenter.add(loadedModelGroup.position); controls.target.copy(modelCenter); controls.update(); bones.length=0; loadedModelGroup.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; originalMaterials.set(child, child.material); } if (child.isBone) bones.push(child); }); scene.add(loadedModelGroup); logToPage(`Model added to scene. ${bones.length} bones found.`); logToPage("Waiting for bone mappings..."); const mappings = await boneMappingPromise; logToPage("Bone mappings available."); populateComponentsInfo(gltf, filename, mappings); populateDebugPanel(mappings); updateDebugPanel(); setInfo(`Loaded ${filename}`, 'success'); savePoseDataBtn.disabled = false; wireframeButton.disabled = false; refreshModelButton.disabled = false; if(transformModeControls) transformModeControls.style.display = 'flex'; if(loadPoseFileBtn) loadPoseFileBtn.disabled = false; updateUndoRedoButtons(); saveInitialState(); saveHistoryState(); onWindowResize(); resolve(); } catch (e) { logToPage(`Error processing GLB: ${e.message}\n${e.stack}`, "error"); setInfo(`Error processing ${filename}`, 'error'); reject(e); } }, (e) => { console.error('Error parsing GLB:', e); logToPage(`Error parsing ${filename}: ${e}`, 'error'); setInfo(`Error parsing ${filename}`, 'error'); reject(e); }); }); }
        function populateComponentsInfo(gltf, filename, mappings) { /* ... definition ... */ meshListElement.innerHTML=''; boneListContainer.innerHTML=''; materialListElement.innerHTML=''; animationListElement.innerHTML=''; let mc=0,matc=0; const uniqueMats=new Set(); gltf.scene.traverse((c)=>{if(c.isMesh){mc++;const li=document.createElement('li');li.textContent=c.name||`Mesh ${mc}`;meshListElement.appendChild(li);const mats=Array.isArray(c.material)?c.material:[c.material];mats.forEach(m=>m&&uniqueMats.add(m));}}); uniqueMats.forEach((m)=>{matc++;const li=document.createElement('li');li.textContent=m.name||`Material ${matc}`;materialListElement.appendChild(li);}); populateBoneList(mappings); if(gltf.animations?.length>0){gltf.animations.forEach((clip)=>{const li=document.createElement('li');li.textContent=clip.name||'Anim Clip';animationListElement.appendChild(li);});}else{animationListElement.innerHTML='<li>No animations</li>';} summaryElement.innerHTML=`<strong>Filename:</strong> ${filename}<br><strong>Bones:</strong> ${bones.length}`; componentsInfoElement.style.display='block'; logToPage("Components info populated."); }
        function populateBoneList(allMappings) { /* ... definition ... */ boneListContainer.innerHTML='';const map=allMappings?allMappings[originalModelPath]:null; if(!map){logToPage(`No bone mapping for ${originalModelPath}. Raw names used.`, "warn");const ul=document.createElement('ul');bones.slice().sort((a,b)=>(a.name||'').localeCompare(b.name||'')).forEach(bone=>{ul.appendChild(createAndAttachListItem({bone:bone,friendlyName:bone.name||'Unnamed'}));});boneListContainer.appendChild(ul);return;} const groups={};const order=['Root','Rigging','Head','Torso','Arms','Hands','Legs','Feet','Other']; bones.forEach(bone=>{const info=map[bone.name];const bi={bone:bone,friendlyName:info?.friendlyName||bone.name||'Unnamed',group:info?.group||'Other',subGroup:info?.subGroup};if(!groups[bi.group])groups[bi.group]={_root:[]};const target=bi.subGroup&&bi.subGroup!=='_root'?bi.subGroup:'_root';if(!groups[bi.group][target])groups[bi.group][target]=[];groups[bi.group][target].push(bi);}); order.forEach(gn=>{const data=groups[gn];if(!data||(data._root.length===0&&Object.keys(data).length===1))return;const det=document.createElement('details');det.open=!['Hands','Feet','Rigging','Other'].includes(gn);const sum=document.createElement('summary');sum.textContent=gn;det.appendChild(sum);const ul=document.createElement('ul');data._root.sort((a,b)=>a.friendlyName.localeCompare(b.friendlyName)).forEach(bi=>{ul.appendChild(createAndAttachListItem(bi));});Object.keys(data).filter(k=>k!=='_root').sort().forEach(sgn=>{const sdet=document.createElement('details');sdet.open=false;const ssum=document.createElement('summary');ssum.textContent=sgn;sdet.appendChild(ssum);const sul=document.createElement('ul');data[sgn].sort((a,b)=>a.friendlyName.localeCompare(b.friendlyName)).forEach(bi=>{sul.appendChild(createAndAttachListItem(bi));});sdet.appendChild(sul);ul.appendChild(sdet);});det.appendChild(ul);boneListContainer.appendChild(det);}); function createAndAttachListItem(bi){const li=document.createElement('li');li.textContent=bi.friendlyName;li.dataset.boneName=bi.bone.name;li.addEventListener('click',handleBoneClick);return li;} }
        function handleBoneClick(event){ /* ... definition ... */ const li=event.currentTarget;const bn=li.dataset.boneName;const tb=bones.find(b=>b.name===bn);if(!tb)return;boneListContainer.querySelector('li.selected')?.classList.remove('selected');li.classList.add('selected');selectedBone=tb;transformControls.attach(tb);const bp=new THREE.Vector3();tb.getWorldPosition(bp);controls.target.copy(bp);controls.update();}
        function toggleWireframe(){ /* ... definition ... */ if(!loadedModelGroup)return;wireframeActive=!wireframeActive;loadedModelGroup.traverse((c)=>{if(c.isMesh){if(wireframeActive){if(!originalMaterials.has(c))originalMaterials.set(c,c.material);c.material=wireframeMaterial;}else{if(originalMaterials.has(c))c.material=originalMaterials.get(c);}}});logToPage(`Wireframe ${wireframeActive?'on':'off'}`,'info');}
        function saveInitialState(){ /* ... definition ... */ initialBoneState=bones.map(b=>({name:b.name,position:b.position.clone(),quaternion:b.quaternion.clone(),scale:b.scale.clone()}));logToPage(`Init state saved ${bones.length} bones.`);}
        function refreshModel(){ /* ... definition ... */ if(!originalModelPath){setInfo("No model","error");return;}setInfo(`Refreshing: ${originalModelPath}`,'loading');loadSelectedModel(originalModelPath);}
        function saveHistoryState(){ /* ... definition ... */ if(!loadedModelGroup||bones.length===0)return;const s=bones.map(b=>({name:b.name,position:b.position.clone(),quaternion:b.quaternion.clone(),scale:b.scale.clone()}));if(historyIndex<history.length-1)history.length=historyIndex+1;history.push(s);if(history.length>MAX_HISTORY)history.shift();historyIndex=history.length-1;updateUndoRedoButtons();}
        function applyHistoryState(idx){ /* ... definition ... */ if(idx<0||idx>=history.length)return;const s=history[idx];let f=false;s.forEach(bs=>{const b=bones.find(b=>b.name===bs.name);if(b){b.position.copy(bs.position);b.quaternion.copy(bs.quaternion);b.scale.copy(bs.scale);f=true;}});if(f&&loadedModelGroup){loadedModelGroup.traverse(o=>{if(o.isSkinnedMesh&&o.skeleton)o.skeleton.update();});}historyIndex=idx;updateUndoRedoButtons();if(selectedBone){transformControls.attach(selectedBone);const bp=new THREE.Vector3();selectedBone.getWorldPosition(bp);controls.target.copy(bp);controls.update();}else{transformControls.detach();controls.target.copy(modelCenter);controls.update();} updateDebugPanel();}
        function undo(){if(historyIndex>0)applyHistoryState(historyIndex-1);}
        function redo(){if(historyIndex<history.length-1)applyHistoryState(historyIndex+1);}
        function updateUndoRedoButtons(){if(!undoButton||!redoButton)return;undoButton.disabled=historyIndex<=0;redoButton.disabled=historyIndex>=history.length-1;}
        function handleKeyDown(event){ /* ... definition ... */ if(document.activeElement&&['INPUT','SELECT','BUTTON','TEXTAREA'].includes(document.activeElement.tagName))return;const ctrl=event.ctrlKey||event.metaKey;const key=event.key.toLowerCase();if(ctrl&&key==='z'){event.preventDefault();undo();}else if(ctrl&&key==='y'){event.preventDefault();redo();}else if(key==='t'){event.preventDefault();transformControls.setMode('translate');}else if(key==='r'){event.preventDefault();transformControls.setMode('rotate');}else if(event.key==='Escape'){event.preventDefault();detachButton.click();}else if(key==='d'){event.preventDefault();toggleDebugPanel();}}
        function savePoseDataLocally(){ /* ... definition ... */ if(!loadedModelGroup||!originalModelPath||bones.length===0){setInfo('Load model first.','error');return;}const n=prompt("Pose name:","New Pose");if(!n?.trim()){setInfo('Save cancelled.','info');return;}const tN=n.trim();setInfo(`Saving pose "${tN}"...`,'loading');try{const d=bones.map(b=>({name:b.name,p:b.position.toArray(),q:b.quaternion.toArray(),s:b.scale.toArray()}));const k=`poses_${originalModelPath}`;let p={};try{const s=localStorage.getItem(k);if(s)p=JSON.parse(s);if(typeof p!=='object'||p===null)p={};}catch(e){console.error(`Err parse ${k}:`,e);p={};}p[tN]=d.map(d=>({name:d.name,position:d.p,quaternion:d.q,scale:d.s}));localStorage.setItem(k,JSON.stringify(p));setInfo(`Pose "${tN}" saved. Refresh.`,'success');console.log(`Pose "${tN}" saved:`,k);}catch(err){console.error('Err save pose:',err);setInfo(`Save failed: ${err.message}`,'error');}}
        function setInfo(message, type='info'){if(!infoElement)return;logToPage(`setInfo: type=${type}, msg=${message}`);infoElement.textContent=message;infoElement.className=type;}
        function handlePoseFileSelect(event){ /* ... definition ... */ if (!loadedModelGroup) { setInfo("Load a model first.", "error"); logToPage("Pose file load cancelled: No model.", "warn"); if (event.target) event.target.value = null; return; } const file = event.target.files?.[0]; if (!file) return; if (!file.name.toLowerCase().endsWith('.json')) { setInfo("Select .json file.", "error"); logToPage(`Invalid file: ${file.name}`, "warn"); event.target.value = null; return; } const reader = new FileReader(); reader.onload = (e) => { const content = e.target.result; let data; try { data = JSON.parse(content); if (!Array.isArray(data)||data.length===0||!data[0].name||!data[0].position||!data[0].quaternion||!data[0].scale){ throw new Error("Invalid JSON structure."); } logToPage(`Applying pose from file: ${file.name}`); const success = applyPoseData(loadedModelGroup, data); if (success) { setInfo(`Applied pose: ${file.name}`, "success"); saveHistoryState(); updateDebugPanel(); /* Update debug */ } else { setInfo(`Failed apply pose: ${file.name}`, "error"); } } catch (err) { console.error(err); logToPage(`Err apply pose file ${file.name}: ${err.message}`, "error"); setInfo(`Err read file: ${err.message}`, "error"); } finally { if (event.target) event.target.value = null; } }; reader.onerror = (e) => { console.error("FileReader error:", e); logToPage(`Error reading file: ${reader.error}`, "error"); setInfo("Error reading file.", "error"); if (event.target) event.target.value = null; }; setInfo(`Reading file: ${file.name}...`, "loading"); reader.readAsText(file); }
        function applyPoseData(modelGroup,poseData){ /* ... definition ... */ if(!modelGroup||!poseData||!Array.isArray(poseData)){logToPage("applyPoseData: Invalid","error");return false;}logToPage(`Applying pose data (${poseData.length} bones)...`);let applied=0,notFound=0,ok=true;const map=new Map();modelGroup.traverse(c=>{if(c.isBone)map.set(c.name,c);});poseData.forEach(pd=>{const bone=map.get(pd.name);if(bone){try{if(pd.position)bone.position.fromArray(pd.position);if(pd.quaternion)bone.quaternion.fromArray(pd.quaternion);if(pd.scale)bone.scale.fromArray(pd.scale);applied++;}catch(e){logToPage(`Err apply bone ${pd.name}: ${e.message}`,'error');ok=false;}}else{notFound++;}});modelGroup.updateMatrixWorld(true);modelGroup.traverse(o=>{if(o.isSkinnedMesh&&o.skeleton){o.skeleton.update();}});logToPage(`Pose applied. Applied:${applied},NotFound:${notFound}. Ok:${ok}`,ok?'info':'warn');return ok;}
        function loadModelFromUrlParam(){ /* ... definition ... */ logToPage("Checking URL params...");const p=new URLSearchParams(window.location.search);const m=p.get('model');if(m){const d=decodeURIComponent(m);logToPage(`URL param found: load '${d}'`);originalModelPath=d;loadSelectedModel(d);}else{logToPage("No 'model' param.","warn");setInfo('Error: No model specified.','error');savePoseDataBtn.disabled=true;wireframeButton.disabled=true;undoButton.disabled=true;redoButton.disabled=true;refreshModelButton.disabled=true;if(transformModeControls)transformModeControls.style.display='none';if(loadPoseFileBtn)loadPoseFileBtn.disabled=true;}}

        // --- Debug Panel Functions ---
        function toggleDebugPanel() { if (!debugPanel) return; const isVisible = debugPanel.style.display !== 'none'; debugPanel.style.display = isVisible ? 'none' : 'block'; logToPage(`Debug panel ${isVisible ? 'hidden' : 'shown'}.`, 'info'); if (!isVisible) { if (loadedBoneMappings && loadedModelGroup) { updateDebugPanel(); } else { debugBoneListContainer.innerHTML = "<p>Load model first.</p>"; } } }
        function clearDebugPanelContent() { if(debugBoneListContainer) debugBoneListContainer.innerHTML = ''; }
        function populateDebugPanel(allMappings) { if (!debugBoneListContainer) return; clearDebugPanelContent(); logToPage("Populating debug panel structure..."); const map = allMappings ? allMappings[originalModelPath] : null; const createList = (boneArray, parent) => { boneArray.sort((a,b)=>(a.name||'').localeCompare(b.name||'')).forEach(bone => { const li = document.createElement('li'); const nameSpan = document.createElement('span'); nameSpan.className = 'bone-name'; const fname = map?.[bone.name]?.friendlyName || bone.name || 'Unnamed'; nameSpan.textContent = `${fname} (${bone.name})`; li.appendChild(nameSpan); const posDiv = document.createElement('div'); posDiv.innerHTML = `<span class="transform-label">Pos:</span> <span class="transform-data" id="debug-${bone.uuid}-pos-x">---</span> <span class="transform-data" id="debug-${bone.uuid}-pos-y">---</span> <span class="transform-data" id="debug-${bone.uuid}-pos-z">---</span>`; li.appendChild(posDiv); const quatDiv = document.createElement('div'); quatDiv.innerHTML = `<span class="transform-label">Quat:</span> <span class="transform-data" id="debug-${bone.uuid}-quat-x">---</span> <span class="transform-data" id="debug-${bone.uuid}-quat-y">---</span> <span class="transform-data" id="debug-${bone.uuid}-quat-z">---</span> <span class="transform-data" id="debug-${bone.uuid}-quat-w">---</span>`; li.appendChild(quatDiv); const scaleDiv = document.createElement('div'); scaleDiv.innerHTML = `<span class="transform-label">Scl:</span> <span class="transform-data" id="debug-${bone.uuid}-scale-x">---</span> <span class="transform-data" id="debug-${bone.uuid}-scale-y">---</span> <span class="transform-data" id="debug-${bone.uuid}-scale-z">---</span>`; li.appendChild(scaleDiv); parent.appendChild(li); if (bone.children.length > 0) { const childUl = document.createElement('ul'); li.appendChild(childUl); createList(bone.children.filter(c => c.isBone), childUl); } }); }; const rootBones = bones.filter(b => !b.parent || !b.parent.isBone); const rootUl = document.createElement('ul'); createList(rootBones, rootUl); debugBoneListContainer.appendChild(rootUl); logToPage("Debug panel populated."); }
        function updateDebugPanel() { if (!debugPanel || debugPanel.style.display === 'none' || !bones || bones.length === 0) { return; } bones.forEach(bone => { try { document.getElementById(`debug-${bone.uuid}-pos-x`).textContent = bone.position.x.toFixed(3); document.getElementById(`debug-${bone.uuid}-pos-y`).textContent = bone.position.y.toFixed(3); document.getElementById(`debug-${bone.uuid}-pos-z`).textContent = bone.position.z.toFixed(3); document.getElementById(`debug-${bone.uuid}-quat-x`).textContent = bone.quaternion.x.toFixed(3); document.getElementById(`debug-${bone.uuid}-quat-y`).textContent = bone.quaternion.y.toFixed(3); document.getElementById(`debug-${bone.uuid}-quat-z`).textContent = bone.quaternion.z.toFixed(3); document.getElementById(`debug-${bone.uuid}-quat-w`).textContent = bone.quaternion.w.toFixed(3); document.getElementById(`debug-${bone.uuid}-scale-x`).textContent = bone.scale.x.toFixed(3); document.getElementById(`debug-${bone.uuid}-scale-y`).textContent = bone.scale.y.toFixed(3); document.getElementById(`debug-${bone.uuid}-scale-z`).textContent = bone.scale.z.toFixed(3); } catch(e){/* ignore */}}); }
        // <<< Function to handle saving debug data >>>
        function handleSaveDebugData() {
            logToPage("Save Debug Data requested...");
            if (!loadedModelGroup || bones.length === 0) {
                setInfo("Load a model first before saving debug data.", "error");
                logToPage("Save Debug Data failed: No model/bones loaded.", "warn");
                return;
            }
            try {
                // 1. Capture current data
                const poseDataArray = bones.map(bone => ({
                    name: bone.name,
                    position: bone.position.toArray(),
                    quaternion: bone.quaternion.toArray(),
                    scale: bone.scale.toArray()
                }));

                // 2. Format as JSON string
                const jsonData = JSON.stringify(poseDataArray, null, 2); // Pretty print

                // 3. Create Blob and URL
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // 4. Create temporary link and trigger download
                const anchor = document.createElement('a');
                anchor.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `debug_pose_${originalModelPath.split('/').pop().replace('.glb','')}_${timestamp}.json`;
                anchor.download = filename;
                document.body.appendChild(anchor); // Required for Firefox
                anchor.click();
                document.body.removeChild(anchor); // Clean up

                // 5. Revoke URL
                URL.revokeObjectURL(url);

                logToPage(`Debug data saved as ${filename}`, "success");
                setInfo("Debug pose data saved.", "success");

            } catch (error) {
                logToPage(`Error saving debug data: ${error.message}`, "error");
                console.error("Save Debug Data Error:", error);
                setInfo("Error saving debug data.", "error");
            }
        }

        // --- Animation Loop Definition (Moved BEFORE init) ---
        function animate() {
            requestAnimationFrame(animate);
            if(controls) controls.update();
            if(renderer && scene && camera) renderer.render(scene, camera);
        }

        // --- INIT FUNCTION DEFINITION ---
        function init() {
            logToPage("Init start...");
            try {
                scene = new THREE.Scene(); scene.background = new THREE.Color(0x333333);
                if (container.clientWidth <= 0 || container.clientHeight <= 0) { logToPage("Container has zero dimensions initially.", "warn"); }
                camera = new THREE.PerspectiveCamera(75, (container.clientWidth / container.clientHeight) || 1, 0.1, 1000); camera.position.set(2, 2, 2);
                renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(container.clientWidth || window.innerWidth, container.clientHeight || window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; container.appendChild(renderer.domElement);
                logToPage("Renderer added."); onWindowResize();
                controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.1; controls.screenSpacePanning = false; controls.minDistance = 0.5; controls.maxDistance = 50; logToPage("OrbitControls setup.");
                transformControls = new TransformControls(camera, renderer.domElement); transformControls.addEventListener('dragging-changed', (event) => { controls.enabled = !event.value; }); transformControls.addEventListener('mouseUp', () => { if (selectedBone) saveHistoryState(); }); transformControls.addEventListener('mode-changed', updateTransformButtonStyles);
                transformControls.addEventListener('objectChange', updateDebugPanel); // <<< Update debug on gizmo change
                scene.add(transformControls); logToPage("TransformControls setup.");
                addLighting();
                gridHelper = new THREE.GridHelper(40, 40, 0x888888, 0x444444); gridHelper.position.y = 0; scene.add(gridHelper); wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, side: THREE.DoubleSide }); logToPage("Helpers and materials setup.");
                // --- Event Listeners ---
                savePoseDataBtn.addEventListener('click', savePoseDataLocally); wireframeButton.addEventListener('click', toggleWireframe); undoButton.addEventListener('click', undo); redoButton.addEventListener('click', redo); refreshModelButton.addEventListener('click', refreshModel); backToShadowRoomBtn.addEventListener('click', () => window.close());
                document.getElementById('rotateButton').addEventListener('click', () => transformControls.setMode('rotate')); document.getElementById('translateButton').addEventListener('click', () => transformControls.setMode('translate'));
                detachButton.addEventListener('click', () => { transformControls.detach(); selectedBone = null; boneListContainer.querySelector('li.selected')?.classList.remove('selected'); controls.target.copy(modelCenter); controls.update(); updateDebugPanel(); /* Update on detach */ });
                window.addEventListener('resize', onWindowResize, false); window.addEventListener('keydown', handleKeyDown);
                loadPoseFileBtn.addEventListener('click', () => { if(loadPoseFileInput) loadPoseFileInput.click(); }); loadPoseFileInput.addEventListener('change', handlePoseFileSelect);
                toggleDebugBtn.addEventListener('click', toggleDebugPanel);
                saveDebugDataBtn.addEventListener('click', handleSaveDebugData); // <<< Listener for Save Debug Data
                logToPage("Event listeners added.");

                loadModelFromUrlParam(); // Start loading model asynchronously

                transformControls.setMode('rotate'); updateTransformButtonStyles();
                animate(); // <<< START Animation Loop >>>
                logToPage("Init complete. Animation loop started.");
            } catch (error) { logToPage(`Critical Init Error: ${error.message}\n${error.stack}`, "error"); container.innerHTML = `<p style='color: red; padding: 20px;'>Initialization Failed: ${error.message}</p>`; }
        }
        // --- END OF INIT FUNCTION DEFINITION ---

        // --- Start Execution ---
        boneMappingPromise = loadBoneMappings(); // Start loading mappings first
        init(); // <<< CALL INIT AT THE VERY END >>>

    </script>

</body>
</html>