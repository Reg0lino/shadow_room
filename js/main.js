// --- Imports ---
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import * as Primitives from './shapes/primitives.js';
import * as Wireframes from './shapes/wireframes.js';
import * as Variations from './shapes/variations.js';
import * as BasicCombinations from './shapes/combinations_basic.js';
import * as SeparatedCombinations from './shapes/combinations_separated.js';
import * as RingsArrays from './shapes/rings_arrays.js';
import * as StaticFigures from './shapes/figures_static.js';
import * as DynamicPeople from './shapes/figures_dynamic_people.js';
import * as DynamicAnimals from './shapes/figures_dynamic_animals.js';
import * as Objects from './shapes/objects.js';
import * as Abstract from './shapes/abstract.js';

// --- Constants ---
const POSEABLE_MODELS = [ 'models/game_character_base.glb', 'models/jumping_man.glb', 'models/male_base0.glb', 'models/male_base1.glb', 'models/male_base2.glb' ];
const INTERACTION_LAYER = 1;
const LOCAL_STORAGE_KEY = 'dynamicPoseExplorerState_v1_2';

// --- Global Variables ---
let scene, camera, renderer, controls;
let spotLight, lightTarget, lightVisualizer;
let floor, gridHelper, axesHelper;
let sceneObjects = [];
let selectedObjectUUID = null;
let objectMaterial;
let floorBaseMaterial;
let originalShapeOptions = [];
let objectBaseY = 0;
let openPoserBtn;
let poseSelect;
let refreshPosesBtn;
let currentModelPath = null;
let loadedModelGroup = null;
let initialBoneTransforms = null;
let focusCameraBtn;
let decoupleCameraBtn;
let isCameraDecoupled = false;
let raycaster;

// --- DOM Elements ---
let sceneContainer, controlsContainer, toggleControlsBtn, shapeSelect, shapeSearchInput, refreshShapeListBtn, copyLogBtn;
let cameraLockBtn, gridHelperToggle;
let resetObjectBtn;
let saveStateBtn, loadStateBtn, resetSceneBtn;
let objectListElement;
let wallHueSlider, wallHueValueSpan, wallSaturationSlider, wallSaturationValueSpan, wallBrightnessSlider, wallBrightnessValueSpan;
let floorHueSlider, floorHueValueSpan, floorSaturationSlider, floorSaturationValueSpan, floorBrightnessSlider, floorBrightnessValueSpan;
let modelYOffsetSlider, modelYOffsetValueSpan;
// let objectPositionXSlider, objectPositionXValueSpan, objectPositionZSlider, objectPositionZValueSpan; // <<< REMOVED Pos X/Z Refs
let objectRotationXSlider, objectRotationXValueSpan, objectRotationYSlider, objectRotationYValueSpan, objectRotationZSlider, objectRotationZValueSpan;
let objectScaleSlider, objectScaleValueSpan;
let modelColorHueSlider, modelColorHueValueSpan, objectBrightnessSlider, objectBrightnessValueSpan;
let objectRoughnessSlider, objectRoughnessValueSpan, objectMetalnessSlider, objectMetalnessValueSpan;
let lightIntensitySlider, lightIntensityValueSpan, lightAngleSlider, lightAngleValueSpan, lightPenumbraSlider, lightPenumbraValueSpan;
let lightXSlider, lightYSlider, lightZSlider, lightXValueSpan, lightYValueSpan, lightZValueSpan;
let poserControlsDiv;
let boneHierarchyContainer;
const debugConsole = document.getElementById('debug-console');


// --- Logging Function ---
function logToPage(message, type = 'log') {
     const consoleEl = debugConsole;
     if (!consoleEl) { console.log("DEBUG CONSOLE NOT FOUND! Msg:", message); return; }
    try { const p = document.createElement('p'); const timestamp = new Date().toLocaleTimeString([], { hour12: false }); p.textContent = `[${timestamp}] ${message}`; if (type === 'error') { p.classList.add('error'); console.error(message); } else if (type === 'success') { p.classList.add('success'); console.log(message); } else if (type === 'warn') { p.classList.add('warn'); console.warn(message); } else { console.log(message); } consoleEl.appendChild(p); consoleEl.scrollTop = consoleEl.scrollHeight; }
    catch (e) { console.error("logToPage failed:", e); console.error("Original message:", message); }
}

// --- Global Error Handlers ---
window.onerror = function (message, source, lineno, colno, error) { logToPage(`GLOBAL ERROR: ${message} at ${source}:${lineno}:${colno}`, 'error'); return true; };
window.onunhandledrejection = function (event) { const reason = event.reason || 'Unknown reason'; let msg = `UNHANDLED REJECTION: `; if (reason instanceof Error) { msg += `${reason.message}\n${reason.stack}`; } else { msg += String(reason); } logToPage(msg, 'error'); };

// --- Shape Creation Mapping ---
const shapeFunctionMap = { /* (Content omitted for brevity - Ensure your full map is here) */
    'sphere': Primitives.createSphereGeometry, 'cube': Primitives.createCubeGeometry, 'cylinder': Primitives.createCylinderGeometry, 'torus': Primitives.createTorusGeometry, 'cone': Primitives.createConeGeometry, 'pyramid': Primitives.createPyramidGeometry, 'capsule': Primitives.createCapsuleGeometry, 'dodecahedron': Primitives.createDodecahedronGeometry, 'icosahedron': Primitives.createIcosahedronGeometry, 'octahedron': Primitives.createOctahedronGeometry, 'tetrahedron': Primitives.createTetrahedronGeometry, 'tall_box': Variations.createTallBoxGeometry, 'flat_box': Variations.createFlatBoxGeometry, 'thin_cylinder': Variations.createThinCylinderGeometry, 'thick_torus': Variations.createThickTorusGeometry, 'thin_torus': Variations.createThinTorusGeometry, 'squashed_sphere': Variations.createSquashedSphereGroup, 'stretched_cube': Variations.createStretchedCubeGroup, 'lowpoly_sphere': Variations.createLowPolySphereGeometry, 'open_cylinder': Variations.createOpenCylinderGeometry, 'half_sphere': Variations.createHalfSphereGeometry, 'stacked_cubes': BasicCombinations.createStackedCubesGroup, 'stacked_cylinders': BasicCombinations.createStackedCylindersGroup, 'stacked_spheres': BasicCombinations.createStackedSpheresGroup, 'snowman': BasicCombinations.createSnowmanGroup, 'stacked_tori': BasicCombinations.createStackedToriGroup, 'sphere_on_cube': BasicCombinations.createSphereOnCubeGroup, 'cube_on_sphere': BasicCombinations.createCubeOnSphereGroup, 'cone_on_cylinder': BasicCombinations.createConeOnCylinderGroup, 'offset_cubes': BasicCombinations.createOffsetCubesGroup, 'offset_spheres': BasicCombinations.createOffsetSpheresGroup, 'offset_capsules': BasicCombinations.createOffsetCapsulesGroup, 'cube_pyramid_stack': BasicCombinations.createCubePyramidStackGroup, 'three_spheres_line': BasicCombinations.createThreeSpheresLineGroup, 'three_cubes_line': BasicCombinations.createThreeCubesLineGroup, 'three_spheres_triangle': BasicCombinations.createThreeSpheresTriangleGroup, 'three_cubes_triangle': BasicCombinations.createThreeCubesTriangleGroup, 'linked_tori': BasicCombinations.createLinkedToriGroup, 'intersecting_cube_sphere': BasicCombinations.createIntersectingCubeSphereGroup, 'intersecting_cylinders': BasicCombinations.createIntersectingCylindersGroup, 'intersecting_tori': BasicCombinations.createIntersectingToriGroup, 'cylinder_thru_torus': BasicCombinations.createCylinderThruTorusGroup, 'sphere_thru_torus': BasicCombinations.createSphereThruTorusGroup, 'cube_thru_torus': BasicCombinations.createCubeThruTorusGroup, 'two_cubes_apart': SeparatedCombinations.createTwoCubesApartGroup, 'two_spheres_apart': SeparatedCombinations.createTwoSpheresApartGroup, 'sphere_cube_apart': SeparatedCombinations.createSphereCubeApartGroup, 'four_corners_cubes': SeparatedCombinations.createFourCornersCubesGroup, 'line_of_cubes': SeparatedCombinations.createLineOfCubesGroup, 'box_with_poles': RingsArrays.createBoxWithPolesGroup, 'cylinder_ring': RingsArrays.createCylinderRingGroup, 'sphere_ring': RingsArrays.createSphereRingGroup, 'cube_ring': RingsArrays.createCubeRingGroup, 'cube_grid_flat': RingsArrays.createCubeGridFlatGroup, 'sphere_grid_flat': RingsArrays.createSphereGridFlatGroup, 'random_cubes_cluster': RingsArrays.createRandomCubesClusterGroup, 'random_spheres_cluster': RingsArrays.createRandomSpheresClusterGroup, 'random_mixed_cluster': RingsArrays.createRandomMixedClusterGroup, 'simple_person': StaticFigures.createSimplePersonGroup, 'person_box': StaticFigures.createPersonBoxGroup, 'person_spheres': StaticFigures.createPersonSpheresGroup, 'person_mixed': StaticFigures.createPersonMixedGroup, 'person_abstract': StaticFigures.createPersonAbstractGroup, 'basic_robot': StaticFigures.createBasicRobotGroup, 'basic_dog': StaticFigures.createBasicDogGroup, 'basic_cat': StaticFigures.createBasicCatGroup, 'person_running': DynamicPeople.createPersonRunningGroup, 'person_jumping': DynamicPeople.createPersonJumpingGroup, 'person_sitting': DynamicPeople.createPersonSittingGroup, 'person_waving': DynamicPeople.createPersonWavingGroup, 'person_reaching': DynamicPeople.createPersonReachingGroup, 'person_fighting_stance': DynamicPeople.createPersonFightingStanceGroup, 'person_yoga_tree': DynamicPeople.createPersonYogaTreeGroup, 'person_thinking': DynamicPeople.createPersonThinkingGroup, 'person_dancing_1': DynamicPeople.createPersonDancing1Group, 'person_dancing_2': DynamicPeople.createPersonDancing2Group, 'person_kneeling': DynamicPeople.createPersonKneelingGroup, 'person_lying_down': DynamicPeople.createPersonLyingDownGroup, 'person_pointing': DynamicPeople.createPersonPointingGroup, 'person_superhero_pose': DynamicPeople.createPersonSuperheroPoseGroup, 'person_walking': DynamicPeople.createPersonWalkingGroup, 'person_cartwheel_prep': DynamicPeople.createPersonCartwheelPrepGroup, 'person_pushup': DynamicPeople.createPersonPushupGroup, 'person_reading_seated': DynamicPeople.createPersonReadingSeatedGroup, 'person_shrugging': DynamicPeople.createPersonShruggingGroup, 'person_bowing': DynamicPeople.createPersonBowingGroup, 'person_tiptoe': DynamicPeople.createPersonTiptoeGroup, 'person_carrying_box': DynamicPeople.createPersonCarryingBoxGroup, 'person_looking_up': DynamicPeople.createPersonLookingUpGroup, 'person_crouching': DynamicPeople.createPersonCrouchingGroup, 'person_balancing_one_leg': DynamicPeople.createPersonBalancingOneLegGroup, 'dog_running': DynamicAnimals.createDogRunningGroup, 'dog_sitting': DynamicAnimals.createDogSittingGroup, 'dog_playing_bow': DynamicAnimals.createDogPlayingBowGroup, 'dog_begging': DynamicAnimals.createDogBeggingGroup, 'dog_lying_down': DynamicAnimals.createDogLyingDownGroup, 'cat_stretching': DynamicAnimals.createCatStretchingGroup, 'cat_playing': DynamicAnimals.createCatPlayingGroup, 'cat_sleeping_curled': DynamicAnimals.createCatSleepingCurledGroup, 'cat_walking_tail_up': DynamicAnimals.createCatWalkingTailUpGroup, 'cat_crouching_low': DynamicAnimals.createCatCrouchingLowGroup, 'bird_flying': DynamicAnimals.createBirdFlyingGroup, 'bird_perched': DynamicAnimals.createBirdPerchedGroup, 'bird_taking_off': DynamicAnimals.createBirdTakingOffGroup, 'bird_pecking': DynamicAnimals.createBirdPeckingGroup, 'bird_wings_folded': DynamicAnimals.createBirdWingsFoldedGroup, 'horse_galloping': DynamicAnimals.createHorseGallopingGroup, 'horse_rearing': DynamicAnimals.createHorseRearingGroup, 'horse_trotting': DynamicAnimals.createHorseTrottingGroup, 'horse_grazing': DynamicAnimals.createHorseGrazingGroup, 'horse_standing': DynamicAnimals.createHorseStandingGroup, 'fish_swimming': DynamicAnimals.createFishSwimmingGroup, 'snake_coiled': DynamicAnimals.createSnakeCoiledGroup, 'snake_slithering': DynamicAnimals.createSnakeSlitheringGroup, 'frog_jumping': DynamicAnimals.createFrogJumpingGroup, 'deer_leaping': DynamicAnimals.createDeerLeapingGroup, 'elephant_walking': DynamicAnimals.createElephantWalkingGroup, 'monkey_hanging': DynamicAnimals.createMonkeyHangingGroup, 'bear_standing': DynamicAnimals.createBearStandingGroup, 'bear_walking_4legs': DynamicAnimals.createBearWalking4LegsGroup, 'rabbit_sitting': DynamicAnimals.createRabbitSittingGroup, 'table_chair': Objects.createTableChairGroup, 'archway': Objects.createArchwayGroup, 'simple_house': Objects.createSimpleHouseGroup, 'dumbbell': Objects.createDumbbellGroup, 'mushroom': Objects.createMushroomGroup, 'simple_tree': Objects.createSimpleTreeGroup, 'stylized_tree': Objects.createStylizedTreeGroup, 'rocket_basic': Objects.createRocketBasicGroup, 'lamp_simple': Objects.createLampSimpleGroup, 'bridge_simple': Objects.createBridgeSimpleGroup, 'simple_car': Objects.createSimpleCarGroup, 'bench_simple': Objects.createBenchSimpleGroup, 'tower_basic': Objects.createTowerBasicGroup, 'stairs_simple': Objects.createStairsSimpleGroup, 'plant_pot': Objects.createPlantPotGroup, 'leaning_tower_cubes': Abstract.createLeaningTowerCubesGroup, 'spiral_cubes': Abstract.createSpiralCubesGroup, 'spiral_spheres': Abstract.createSpiralSpheresGroup, 'abstract_sculpture_1': Abstract.createAbstractSculpture1Group, 'abstract_sculpture_2': Abstract.createAbstractSculpture2Group, 'abstract_sculpture_3': Abstract.createAbstractSculpture3Group, 'abstract_sculpture_4': Abstract.createAbstractSculpture4Group, 'saturn_like': Abstract.createSaturnLikeGroup, 'wireframe_cube_nested': Wireframes.createWireframeCubeNestedBase, 'wireframe_icosahedron_in_sphere': Wireframes.createIcosahedronInSphereBase
};

// --- ALL FUNCTION DEFINITIONS (Placed BEFORE init) ---

function getDOMElements() {
    logToPage("Getting DOM elements...");
    sceneContainer = document.getElementById('scene-container'); controlsContainer = document.getElementById('controls-container'); toggleControlsBtn = document.getElementById('toggleControlsBtn'); shapeSelect = document.getElementById('shapeSelect'); shapeSearchInput = document.getElementById('shapeSearch'); refreshShapeListBtn = document.getElementById('refreshShapeListBtn'); copyLogBtn = document.getElementById('copyLogBtn'); cameraLockBtn = document.getElementById('cameraLockBtn'); gridHelperToggle = document.getElementById('gridHelperToggle'); resetObjectBtn = document.getElementById('resetObjectBtn'); saveStateBtn = document.getElementById('saveStateBtn'); loadStateBtn = document.getElementById('loadStateBtn'); resetSceneBtn = document.getElementById('resetSceneBtn');
    wallHueSlider = document.getElementById('wallHue'); wallHueValueSpan = document.getElementById('wallHueValue'); wallSaturationSlider = document.getElementById('wallSaturation'); wallSaturationValueSpan = document.getElementById('wallSaturationValue'); wallBrightnessSlider = document.getElementById('wallBrightness'); wallBrightnessValueSpan = document.getElementById('wallBrightnessValue'); floorHueSlider = document.getElementById('floorHue'); floorHueValueSpan = document.getElementById('floorHueValue'); floorSaturationSlider = document.getElementById('floorSaturation'); floorSaturationValueSpan = document.getElementById('floorSaturationValue'); floorBrightnessSlider = document.getElementById('floorBrightness'); floorBrightnessValueSpan = document.getElementById('floorBrightnessValue');
    modelYOffsetSlider = document.getElementById('modelYOffset'); modelYOffsetValueSpan = document.getElementById('modelYOffsetValue');
    // objectPositionXSlider = document.getElementById('objectPositionX'); objectPositionXValueSpan = document.getElementById('objectPositionXValue'); // <<< REMOVED Pos X Ref
    // objectPositionZSlider = document.getElementById('objectPositionZ'); objectPositionZValueSpan = document.getElementById('objectPositionZValue'); // <<< REMOVED Pos Z Ref
    objectRotationXSlider = document.getElementById('objectRotationX'); objectRotationXValueSpan = document.getElementById('objectRotationXValue'); objectRotationYSlider = document.getElementById('objectRotationY'); objectRotationYValueSpan = document.getElementById('objectRotationYValue'); objectRotationZSlider = document.getElementById('objectRotationZ'); objectRotationZValueSpan = document.getElementById('objectRotationZValue'); objectScaleSlider = document.getElementById('objectScale'); objectScaleValueSpan = document.getElementById('objectScaleValue'); modelColorHueSlider = document.getElementById('modelColorHue'); modelColorHueValueSpan = document.getElementById('modelColorHueValue'); objectBrightnessSlider = document.getElementById('objectBrightness'); objectBrightnessValueSpan = document.getElementById('objectBrightnessValue'); objectRoughnessSlider = document.getElementById('objectRoughness'); objectRoughnessValueSpan = document.getElementById('objectRoughnessValue'); objectMetalnessSlider = document.getElementById('objectMetalness'); objectMetalnessValueSpan = document.getElementById('objectMetalnessValue');
    lightIntensitySlider = document.getElementById('lightIntensity'); lightIntensityValueSpan = document.getElementById('lightIntensityValue'); lightAngleSlider = document.getElementById('lightAngle'); lightAngleValueSpan = document.getElementById('lightAngleValue'); lightPenumbraSlider = document.getElementById('lightPenumbra'); lightPenumbraValueSpan = document.getElementById('lightPenumbraValue'); lightXSlider = document.getElementById('lightX'); lightXValueSpan = document.getElementById('lightXValue'); lightYSlider = document.getElementById('lightY'); lightYValueSpan = document.getElementById('lightYValue'); lightZSlider = document.getElementById('lightZ'); lightZValueSpan = document.getElementById('lightZValue');
    openPoserBtn = document.getElementById('openPoserBtn'); poseSelect = document.getElementById('poseSelect'); refreshPosesBtn = document.getElementById('refreshPosesBtn'); objectListElement = document.getElementById('objectList'); focusCameraBtn = document.getElementById('focusCameraBtn'); decoupleCameraBtn = document.getElementById('decoupleCameraBtn');
    logToPage("DOM elements assigned.");
     const req = [ sceneContainer, controlsContainer, toggleControlsBtn, shapeSelect, shapeSearchInput, refreshShapeListBtn, copyLogBtn, cameraLockBtn, gridHelperToggle, resetObjectBtn, saveStateBtn, loadStateBtn, resetSceneBtn, wallHueSlider, wallHueValueSpan, wallSaturationSlider, wallSaturationValueSpan, wallBrightnessSlider, wallBrightnessValueSpan, floorHueSlider, floorHueValueSpan, floorSaturationSlider, floorSaturationValueSpan, floorBrightnessSlider, floorBrightnessValueSpan, modelYOffsetSlider, modelYOffsetValueSpan, /* <<< REMOVED Pos X/Z Check >>> */ objectRotationXSlider, objectRotationXValueSpan, objectRotationYSlider, objectRotationYValueSpan, objectRotationZSlider, objectRotationZValueSpan, objectScaleSlider, objectScaleValueSpan, modelColorHueSlider, modelColorHueValueSpan, objectBrightnessSlider, objectBrightnessValueSpan, objectRoughnessSlider, objectRoughnessValueSpan, objectMetalnessSlider, objectMetalnessValueSpan, lightIntensitySlider, lightIntensityValueSpan, lightAngleSlider, lightAngleValueSpan, lightPenumbraSlider, lightPenumbraValueSpan, lightXSlider, lightYSlider, lightZSlider, lightXValueSpan, lightYValueSpan, lightZValueSpan, openPoserBtn, poseSelect, refreshPosesBtn, objectListElement, focusCameraBtn, decoupleCameraBtn ];
     if (req.some(el => !el)) { const names = [ "sceneContainer", "controlsContainer", "toggleControlsBtn", "shapeSelect", "shapeSearchInput", "refreshShapeListBtn", "copyLogBtn", "cameraLockBtn", "gridHelperToggle", "resetObjectBtn", "saveStateBtn", "loadStateBtn", "resetSceneBtn", "wallHueSlider", "wallHueValueSpan", "wallSaturationSlider", "wallSaturationValueSpan", "wallBrightnessSlider", "wallBrightnessValueSpan", "floorHueSlider", "floorHueValueSpan", "floorSaturationSlider", "floorSaturationValueSpan", "floorBrightnessSlider", "floorBrightnessValueSpan", "modelYOffsetSlider", "modelYOffsetValueSpan", /* <<< REMOVED Pos X/Z Check Names >>> */ "objectRotationXSlider", "objectRotationXValueSpan", "objectRotationYSlider", "objectRotationYValueSpan", "objectRotationZSlider", "objectRotationZValueSpan", "objectScaleSlider", "objectScaleValueSpan", "modelColorHueSlider", "modelColorHueValueSpan", "objectBrightnessSlider", "objectBrightnessValueSpan", "objectRoughnessSlider", "objectRoughnessValueSpan", "objectMetalnessSlider", "objectMetalnessValueSpan", "lightIntensitySlider", "lightIntensityValueSpan", "lightAngleSlider", "lightAngleValueSpan", "lightPenumbraSlider", "lightPenumbraValueSpan", "lightXSlider", "lightYSlider", "lightZSlider", "lightXValueSpan", "lightYValueSpan", "lightZValueSpan", "openPoserBtn", "poseSelect", "refreshPosesBtn", "objectListElement", "focusCameraBtn", "decoupleCameraBtn" ]; const missing = req.map((el, i) => el ? null : names[i]).filter(n => n !== null); logToPage(`CRITICAL ERROR: Missing DOM elements: ${missing.join(', ')}.`, 'error'); throw new Error("Essential elements missing!"); }
}
function storeOriginalOptions() { if(!shapeSelect)return; logToPage("Storing original options..."); try{originalShapeOptions=Array.from(shapeSelect.options).map(o=>({value:o.value,text:o.text,styleDisplay:o.style.display||''}));logToPage(`Stored ${originalShapeOptions.length} options.`);}catch(e){logToPage(`Error storing opts: ${e.message}`,'error');}}
function filterShapeDropdown() { if(!shapeSelect||!shapeSearchInput||!originalShapeOptions)return; const term=shapeSearchInput.value.toLowerCase().trim().replace(/_/g,' '); const currentVal=shapeSelect.value; let newIndex=-1, firstIndex=-1; shapeSelect.innerHTML=''; let count=0; originalShapeOptions.forEach(o=>{if(o.styleDisplay==='none')return; const match=term===''||o.value.toLowerCase().replace(/_/g,' ').includes(term)||o.text.toLowerCase().includes(term); if(match){const n=document.createElement('option');n.value=o.value;n.textContent=o.text;shapeSelect.appendChild(n);const idx=shapeSelect.options.length-1;if(firstIndex===-1)firstIndex=idx;if(o.value===currentVal)newIndex=idx;count++;}}); if(shapeSelect.options.length===0){const n=document.createElement('option');n.textContent="No matches";n.disabled=true;shapeSelect.appendChild(n);}else if(newIndex!==-1){shapeSelect.selectedIndex=newIndex;}else if(firstIndex!==-1){shapeSelect.selectedIndex=firstIndex;}else{shapeSelect.selectedIndex=-1;}}
function resetShapeDropdown() { if(!shapeSearchInput||!shapeSelect)return; logToPage("Reset shape dropdown."); shapeSearchInput.value=''; const val=shapeSelect.value; filterShapeDropdown(); shapeSelect.value=val; if(shapeSelect.selectedIndex===-1&&shapeSelect.options.length>0&&!shapeSelect.options[0].disabled)shapeSelect.selectedIndex=0;}
function createObject(shapeType, s, matClone) { const fn = shapeFunctionMap[shapeType]; if (fn) { try { return fn(s, matClone); } catch (e) { logToPage(`Shape Error (${shapeType}): ${e.message}`, 'error'); return Primitives.createSphereGeometry(s); } } else { logToPage(`Unknown shape: ${shapeType}`, 'error'); return Primitives.createSphereGeometry(s); } }
function getSelectedObject3D() { if (!selectedObjectUUID) return null; const d = sceneObjects.find(o => o.uuid === selectedObjectUUID); return d ? d.object3D : null; }
function isPoseableModel(modelPath) { return typeof modelPath === 'string' && POSEABLE_MODELS.includes(modelPath) && modelPath.toLowerCase().endsWith('.glb'); }
function base64ToArrayBuffer(base64) { try { const bin = window.atob(base64); const len = bin.length; const bytes = new Uint8Array(len); for (let i = 0; i < len; i++) { bytes[i] = bin.charCodeAt(i); } return bytes.buffer; } catch (e) { logToPage(`Base64 decode err: ${e.message}`, 'error'); throw e; } }
function applyPoseData(modelGroup, poseData) { if (!modelGroup || !poseData || !Array.isArray(poseData)) { logToPage("Apply pose data: Invalid args.", 'error'); return false; } let applied=0, notFound=0, ok=true; const boneMap = new Map(); modelGroup.traverse(c => { if (c.isBone) boneMap.set(c.name, c); }); poseData.forEach(p => { const bone = boneMap.get(p.name); if (bone) { try { if (p.position) bone.position.fromArray(p.position); if (p.quaternion) bone.quaternion.fromArray(p.quaternion); if (p.scale) bone.scale.fromArray(p.scale); applied++; } catch (e) { logToPage(`Err apply bone ${p.name}: ${e.message}`, 'error'); ok=false; } } else { notFound++; } }); modelGroup.updateMatrixWorld(true); modelGroup.traverse(o => { if (o.isSkinnedMesh && o.skeleton) o.skeleton.update(); }); if(notFound > 0) logToPage(`Pose applied. Applied:${applied}, Not Found:${notFound}.`, ok ? 'success' : 'warn'); else if(applied > 0) logToPage(`Pose applied ${applied} bones.`, 'success'); return ok; }
function processLoadedGltf(gltf, targetHeight, modelPath) { try { logToPage(`Processing GLTF: ${modelPath}`); const model = gltf.scene || gltf.scenes?.[0]; if (!model) throw new Error("No scene data"); initialBoneTransforms = null; loadedModelGroup = model; if (isPoseableModel(modelPath)) { logToPage(`Poseable model: ${modelPath}`); initialBoneTransforms = []; model.traverse(c => { if (c.isBone) initialBoneTransforms.push({ name: c.name, position: c.position.clone(), quaternion: c.quaternion.clone(), scale: c.scale.clone() }); }); logToPage(`Stored ${initialBoneTransforms?.length || 0} initial bone transforms.`); } else { logToPage(`Not poseable: ${modelPath}`); } currentModelPath = modelPath; const box=new THREE.Box3().setFromObject(model); const size=new THREE.Vector3(); box.getSize(size); let scale=1.0; if(size.y>0.001){scale=targetHeight/size.y;}else{logToPage("Zero height model, scale=1.",'warn');} model.scale.set(scale, scale, scale); model.updateMatrixWorld(true); model.traverse(c => { if (c.isMesh) { c.castShadow=true; c.receiveShadow=true; } }); logToPage(`Processed GLTF: ${modelPath}.`, 'success'); return model; } catch (e) { logToPage(`Error processing GLTF ${modelPath}: ${e.message}`, 'error'); console.error(e); throw e; } }
async function loadGLBModel(source, targetHeight = 3.0) { const loader = new GLTFLoader(); const isData = source instanceof ArrayBuffer; const desc = isData ? 'buffer' : source; logToPage(`Loading GLB from ${desc}...`); return new Promise((resolve, reject) => { const onLoad = (gltf) => { try { const path = isData ? currentModelPath : source; if (!path) throw new Error("Unknown model path for processing."); const group = processLoadedGltf(gltf, targetHeight, path); resolve(group); } catch (e) { reject(e); } }; const onError = (e) => { const msg = e.message || JSON.stringify(e); logToPage(`Fail load/parse GLB ${desc}: ${msg}`, 'error'); console.error(e); reject(new Error(`GLB Error: ${msg}`)); }; if (isData) { loader.parse(source, '', onLoad, onError); } else { loader.load(source, onLoad, undefined, onError); } }).catch(e => { logToPage(`GLB load fail ${desc}. Fallback box. Err: ${e.message}`, 'error'); const fallbackGeo = Primitives.createCubeGeometry(1.0); const mat = objectMaterial || new THREE.MeshStandardMaterial({color:0xff0000}); const mesh = new THREE.Mesh(fallbackGeo, mat.clone()); mesh.castShadow=true; mesh.receiveShadow=true; mesh.name="Fallback"; const group = new THREE.Group(); group.add(mesh); return group; }); }
function loadPosesForModel(modelPath) { if (!poseSelect || !modelPath) return; logToPage(`Loading poses for: ${modelPath}`); poseSelect.innerHTML = ''; const defOpt = document.createElement('option'); defOpt.value = ''; defOpt.textContent = 'Default Pose'; poseSelect.appendChild(defOpt); const key = `poses_${modelPath}`; let poses = {}; try { const stored = localStorage.getItem(key); if (stored) { poses = JSON.parse(stored); if (typeof poses !== 'object' || poses === null) { poses = {}; logToPage(`Invalid pose data ${modelPath}. Reset.`, 'warn'); } } } catch (e) { logToPage(`Error parsing poses ${modelPath}: ${e.message}`, 'error'); poses = {}; } const names = Object.keys(poses).sort(); logToPage(`Found ${names.length} saved poses.`); names.forEach(name => { const opt = document.createElement('option'); opt.value = name; opt.textContent = name; poseSelect.appendChild(opt); }); poseSelect.value = ''; }
function applyPose(poseName) { const data = sceneObjects.find(o => o.uuid === selectedObjectUUID); const model = data?.object3D; const path = data?.originalType; if (!model || !path || !data.isPoseable) { logToPage("Cannot apply pose: No poseable selected.", 'error'); return; } logToPage(`Applying pose "${poseName||'Default'}" to ${selectedObjectUUID} (${path})`); if (!poseName) { logToPage("Applying default pose..."); if (initialBoneTransforms && currentModelPath === path) { const ok = applyPoseData(model, initialBoneTransforms); logToPage(`Applied initial state: ${ok ? 'OK' : 'Fail'}`); } else { logToPage("Cannot apply default: Initial state unavailable/mismatch.", 'warn'); if (poseSelect) poseSelect.value = ''; } return; } const key = `poses_${path}`; let pData = null; try { const stored = localStorage.getItem(key); if (stored) { const all = JSON.parse(stored); if (all?.[poseName]) pData = all[poseName]; } } catch (e) { logToPage(`Error loading pose ${poseName} for ${path}: ${e.message}`, 'error'); } if (pData) { const ok = applyPoseData(model, pData); if (!ok) logToPage(`Errors applying pose ${poseName}.`, 'error'); else logToPage(`Pose ${poseName} applied.`, 'success'); } else { logToPage(`Pose data ${poseName} not found/invalid for ${path}.`, 'error'); if (poseSelect) poseSelect.value = ''; } }
function resetObjectTransforms() { if(objectRotationXSlider) objectRotationXSlider.value=0; if(objectRotationYSlider) objectRotationYSlider.value=0; if(objectRotationZSlider) objectRotationZSlider.value=0; if(objectScaleSlider) objectScaleSlider.value=1.0; //if(objectPositionXSlider) objectPositionXSlider.value=0; // <<< REMOVED Reset X //if(objectPositionZSlider) objectPositionZSlider.value=0; // <<< REMOVED Reset Z logToPage("Object transform sliders reset visually."); updateObjectRotationDisplay(); if(objectScaleValueSpan) objectScaleValueSpan.textContent='1.00x'; //if(objectPositionXValueSpan) objectPositionXValueSpan.textContent='0.0'; // <<< REMOVED Update X Span //if(objectPositionZValueSpan) objectPositionZValueSpan.textContent='0.0'; // <<< REMOVED Update Z Span const obj = getSelectedObject3D(); if(obj){ obj.rotation.set(0,0,0); obj.quaternion.setFromEuler(obj.rotation); obj.scale.set(1,1,1); //obj.position.x=0; // <<< REMOVED Apply X Reset //obj.position.z=0; // <<< REMOVED Apply Z Reset onModelYOffsetChange(); updateTargets(); logToPage("Selected object transforms reset."); } }
function updateTargets() { const obj = getSelectedObject3D(); const target = obj || new THREE.Object3D(); if (!lightTarget || !controls || !spotLight) return; const center = new THREE.Vector3(); try { target.updateMatrixWorld(true); const bounds = new THREE.Box3().setFromObject(target, true); if (!bounds.isEmpty() && !bounds.getSize(new THREE.Vector3()).equals(new THREE.Vector3(0,0,0))) { bounds.getCenter(center); } else { center.copy(target.position); const scaleY = target.scale ? target.scale.y : 1.0; center.y += Math.min(0.5 * scaleY, 1.0); if(obj) logToPage("Warn: Bad bounds, targeting estimated center.", 'warn'); else center.set(0,1,0); } } catch (e) { if(obj) logToPage(`Target calc err: ${e.message}. Using position.`, 'error'); center.copy(target.position); if (!obj) center.set(0,1,0); } lightTarget.position.copy(center); spotLight.target.updateMatrixWorld(); if (lightVisualizer && spotLight) lightVisualizer.position.copy(spotLight.position); if (!isCameraDecoupled) { controls.target.copy(center); } }
function updateSliderValuesFromObject() { const obj = getSelectedObject3D(); if(modelColorHueSlider && objectBrightnessSlider && objectRoughnessSlider && objectMetalnessSlider){ let mat = null; if (obj) { if (obj.isMesh && obj.material?.isMeshStandardMaterial) mat=obj.material; else if (obj.isGroup) obj.traverse(c => { if (!mat && c.isMesh && c.material?.isMeshStandardMaterial) mat=c.material; }); } if (!mat) mat=objectMaterial; if (mat?.isMeshStandardMaterial) { const hsl={h:0,s:0,l:0}; mat.color.getHSL(hsl); const hue = hsl.s===0 ? parseFloat(modelColorHueSlider.value):hsl.h; const hasMap = mat.map!==null; modelColorHueSlider.disabled=hasMap; objectBrightnessSlider.disabled=hasMap; if (hasMap) { modelColorHueSlider.style.opacity=0.5; objectBrightnessSlider.style.opacity=0.5; modelColorHueValueSpan.textContent='N/A'; objectBrightnessValueSpan.textContent='N/A'; } else { modelColorHueSlider.style.opacity=1; objectBrightnessSlider.style.opacity=1; modelColorHueSlider.value=hue; objectBrightnessSlider.value=hsl.l; modelColorHueValueSpan.textContent=`${Math.round(hue*360)}°`; objectBrightnessValueSpan.textContent=hsl.l.toFixed(2); } objectRoughnessSlider.value=mat.roughness; objectMetalnessSlider.value=mat.metalness; objectRoughnessValueSpan.textContent=mat.roughness.toFixed(2); objectMetalnessValueSpan.textContent=mat.metalness.toFixed(2); if(!modelColorHueSlider.disabled) modelColorHueSlider.dispatchEvent(new Event('input')); if(!objectBrightnessSlider.disabled) objectBrightnessSlider.dispatchEvent(new Event('input')); objectRoughnessSlider.dispatchEvent(new Event('input')); objectMetalnessSlider.dispatchEvent(new Event('input')); } } if(obj){ if(modelYOffsetSlider&&modelYOffsetValueSpan){const b=new THREE.Box3().setFromObject(obj,true);let baseY=0;if(!b.isEmpty()&&!b.getSize(new THREE.Vector3()).equals(new THREE.Vector3(0,0,0)))baseY=-b.min.y;else baseY=obj.position.y-parseFloat(modelYOffsetSlider.value);const offset=obj.position.y-baseY;modelYOffsetSlider.value=offset;modelYOffsetValueSpan.textContent=offset.toFixed(1);} // <<< REMOVED Position X/Z Update >>> // if (objectPositionXSlider && objectPositionXValueSpan) { //     objectPositionXSlider.value = obj.position.x; //     objectPositionXValueSpan.textContent = obj.position.x.toFixed(1); // } // if (objectPositionZSlider && objectPositionZValueSpan) { //     objectPositionZSlider.value = obj.position.z; //     objectPositionZValueSpan.textContent = obj.position.z.toFixed(1); // } // <<< END REMOVED Position X/Z Update >>> if(objectRotationXSlider){const e=new THREE.Euler().setFromQuaternion(obj.quaternion,'XYZ');objectRotationXSlider.value=THREE.MathUtils.radToDeg(e.x);objectRotationYSlider.value=THREE.MathUtils.radToDeg(e.y);objectRotationZSlider.value=THREE.MathUtils.radToDeg(e.z);updateObjectRotationDisplay();} if(objectScaleSlider&&objectScaleValueSpan){const s=obj.scale.x;objectScaleSlider.value=s;objectScaleValueSpan.textContent=s.toFixed(2)+'x';} }else{ if(objectMaterial){const hsl={h:0,s:0,l:0};objectMaterial.color.getHSL(hsl); if(modelColorHueSlider)modelColorHueSlider.value=hsl.h;if(objectBrightnessSlider)objectBrightnessSlider.value=hsl.l; if(objectRoughnessSlider)objectRoughnessSlider.value=objectMaterial.roughness;if(objectMetalnessSlider)objectMetalnessSlider.value=objectMaterial.metalness; if(modelColorHueSlider)modelColorHueSlider.dispatchEvent(new Event('input'));if(objectBrightnessSlider)objectBrightnessSlider.dispatchEvent(new Event('input')); if(objectRoughnessSlider)objectRoughnessSlider.dispatchEvent(new Event('input'));if(objectMetalnessSlider)objectMetalnessSlider.dispatchEvent(new Event('input'));} if(modelYOffsetSlider){modelYOffsetSlider.value=0;modelYOffsetSlider.dispatchEvent(new Event('input'));} // <<< REMOVED Reset X // if(objectPositionXSlider){objectPositionXSlider.value=0;objectPositionXSlider.dispatchEvent(new Event('input'));if(objectPositionXValueSpan)objectPositionXValueSpan.textContent='0.0';} // <<< REMOVED Reset Z // if(objectPositionZSlider){objectPositionZSlider.value=0;objectPositionZSlider.dispatchEvent(new Event('input'));if(objectPositionZValueSpan)objectPositionZValueSpan.textContent='0.0';} if(objectRotationXSlider){objectRotationXSlider.value=0;objectRotationXSlider.dispatchEvent(new Event('input'));} if(objectRotationYSlider){objectRotationYSlider.value=0;objectRotationYSlider.dispatchEvent(new Event('input'));} if(objectRotationZSlider){objectRotationZSlider.value=0;objectRotationZSlider.dispatchEvent(new Event('input'));} if(objectScaleSlider){objectScaleSlider.value=1;objectScaleSlider.dispatchEvent(new Event('input'));} } }
async function updateObject(type) { /* ... */ logToPage(`Update Object: ${type}`); const s=1.5; if(!objectMaterial){logToPage("ERR: No objectMaterial!",'error');return null;} let newObj=null; const isGlb=typeof type==='string'&&type.toLowerCase().endsWith('.glb'); const isPose=typeof type==='string'&&type.startsWith('apply_pose:'); let modelPath=type; let pose=null; let objType='primitive'; try{ if(isPose){ objType='posed_glb'; const parts=type.substring(11).split('?pose='); modelPath=parts[0]; pose=parts.length>1?decodeURIComponent(parts[1]):null; logToPage(`Load model ${modelPath} for pose: ${pose||'Default'}`); newObj=await loadGLBModel(modelPath); }else if(isGlb){ objType='glb'; logToPage(`Load GLB: ${modelPath}`); newObj=await loadGLBModel(modelPath); }else{ objType='primitive'; logToPage(`Create geo: ${modelPath}`); const isWire=modelPath.startsWith('wireframe_'); const baseType=isWire?modelPath.substring(10):modelPath; const primMat=objectMaterial.clone(); const hue=Math.random(); primMat.color.setHSL(hue,0.8,parseFloat(objectBrightnessSlider?.value||0.5)); logToPage(`Rand primitive hue: ${Math.round(hue*360)}°`); let item=createObject(baseType,s,()=>primMat); if(!item)throw new Error(`Create func fail ${baseType}`); if(item instanceof THREE.BufferGeometry){ logToPage(`Geo created ${baseType}. Make mesh.`); if(isWire)primMat.wireframe=true; newObj=new THREE.Mesh(item,primMat); newObj.castShadow=true; newObj.receiveShadow=true; }else if(item instanceof THREE.Group){ logToPage(`Group created ${baseType}.`); newObj=item; newObj.traverse(c=>{if(c.isMesh){c.castShadow=true;c.receiveShadow=true;if(!c.material||c.material===objectMaterial){c.material=primMat;}else if(Array.isArray(c.material)){c.material=c.material.map(m=>(!m||m===objectMaterial)?primMat:m);} if(isWire&&c.material!==primMat){c.material.wireframe=true;}else if(isWire&&c.material===primMat){primMat.wireframe=true;}}}); if(isWire)logToPage(`Applied wireframe.`); }else{ throw new Error(`Unexpected type ${typeof item}`); } } if(!newObj)throw new Error("Object creation fail."); logToPage(`updateObject OK: ${type}`); return{object3D:newObj,type:objType,originalType:type,poseToApply:pose}; }catch(e){logToPage(`FAIL updateObject ${type}: ${e.message}`,'error');console.error(e);return null;} }
function onModelYOffsetChange() { /* ... */ const obj=getSelectedObject3D(); if(!obj||!modelYOffsetSlider||!modelYOffsetValueSpan)return; try{const offset=parseFloat(modelYOffsetSlider.value);modelYOffsetValueSpan.textContent=offset.toFixed(1);const bounds=new THREE.Box3().setFromObject(obj,true);let baseY=0;if(!bounds.isEmpty()&&!bounds.getSize(new THREE.Vector3()).equals(new THREE.Vector3(0,0,0)))baseY=-bounds.min.y;else baseY=obj.position.y-offset;obj.position.y=baseY+offset;updateTargets();}catch(e){logToPage(`Y Offset err: ${e.message}`,'error')}}
// --- Removed onObjectPositionChange Function ---
// function onObjectPositionChange() { /* ... */ }
function onObjectRotationChange() { /* ... */ const obj=getSelectedObject3D(); if(!obj||!objectRotationXSlider||!objectRotationYSlider||!objectRotationZSlider)return; try{const rx=parseFloat(objectRotationXSlider.value);const ry=parseFloat(objectRotationYSlider.value);const rz=parseFloat(objectRotationZSlider.value);const qx=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),THREE.MathUtils.degToRad(rx));const qy=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),THREE.MathUtils.degToRad(ry));const qz=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),THREE.MathUtils.degToRad(rz));obj.quaternion.copy(qy).multiply(qx).multiply(qz);updateObjectRotationDisplay();updateTargets();}catch(e){logToPage(`Rot change err: ${e.message}`,'error')}}
function onObjectScaleChange() { /* ... */ const obj=getSelectedObject3D(); if(!obj||!objectScaleSlider||!objectScaleValueSpan)return; try{const s=parseFloat(objectScaleSlider.value);obj.scale.set(s,s,s);objectScaleValueSpan.textContent=s.toFixed(2)+'x';onModelYOffsetChange();}catch(e){logToPage(`Scale change err: ${e.message}`,'error');}}
function updateObjectRotationDisplay() { /* ... */ try{if(objectRotationXValueSpan&&objectRotationXSlider)objectRotationXValueSpan.textContent=`${parseFloat(objectRotationXSlider.value)}°`;if(objectRotationYValueSpan&&objectRotationYSlider)objectRotationYValueSpan.textContent=`${parseFloat(objectRotationYSlider.value)}°`;if(objectRotationZValueSpan&&objectRotationZSlider)objectRotationZValueSpan.textContent=`${parseFloat(objectRotationZSlider.value)}°`;}catch(e){logToPage(`Update rot disp err: ${e.message}`,'error')}}
function onModelColorOrBrightnessChange() { /* ... */ const obj=getSelectedObject3D(); if((!obj&&!objectMaterial)||!modelColorHueSlider||!objectBrightnessSlider)return; try{const h=parseFloat(modelColorHueSlider.value);const l=parseFloat(objectBrightnessSlider.value);const s=0.8;if(modelColorHueValueSpan)modelColorHueValueSpan.textContent=`${Math.round(h*360)}°`;if(objectBrightnessValueSpan)objectBrightnessValueSpan.textContent=l.toFixed(2);const apply=(m)=>{if(m?.isMeshStandardMaterial&&!m.map){m.color.setHSL(h,s,l);return true;}return false;};let changed=false;if(obj){if(obj.isMesh){if(apply(obj.material))changed=true;}else if(obj.isGroup){obj.traverse(c=>{if(c.isMesh&&c.material){if(Array.isArray(c.material))c.material.forEach(m=>{if(apply(m))changed=true;});else if(apply(c.material))changed=true;}});}}else if(objectMaterial){if(apply(objectMaterial))changed=true;}}catch(e){logToPage(`Color/Bright err: ${e.message}`,'error')}}
function onObjectMaterialChange() { /* ... */ const obj=getSelectedObject3D(); if((!obj&&!objectMaterial)||!objectRoughnessSlider||!objectMetalnessSlider)return; try{const r=parseFloat(objectRoughnessSlider.value);const m=parseFloat(objectMetalnessSlider.value);if(objectRoughnessValueSpan)objectRoughnessValueSpan.textContent=r.toFixed(2);if(objectMetalnessValueSpan)objectMetalnessValueSpan.textContent=m.toFixed(2);const apply=(mat)=>{if(mat?.isMeshStandardMaterial){mat.roughness=r;mat.metalness=m;mat.needsUpdate=true;return true;}return false;};let changed=false;if(obj){if(obj.isMesh){if(apply(obj.material))changed=true;}else if(obj.isGroup){obj.traverse(c=>{if(c.isMesh&&c.material){if(Array.isArray(c.material))c.material.forEach(mat=>{if(apply(mat))changed=true;});else if(apply(c.material))changed=true;}});}}else if(objectMaterial){if(apply(objectMaterial))changed=true;}}catch(e){logToPage(`Material props err: ${e.message}`,'error')}}
function onLightIntensityChange() { /* ... */ if(!spotLight||!lightIntensityValueSpan||!lightIntensitySlider)return;try{spotLight.intensity=parseFloat(lightIntensitySlider.value);lightIntensityValueSpan.textContent=spotLight.intensity.toFixed(1);}catch(e){logToPage(`Intensity err: ${e.message}`,'error')}}
function onSpotlightParamsChange() { /* ... */ if(!spotLight||!lightAngleValueSpan||!lightPenumbraValueSpan||!lightAngleSlider||!lightPenumbraSlider)return;try{const a=parseFloat(lightAngleSlider.value);const p=parseFloat(lightPenumbraSlider.value);spotLight.angle=THREE.MathUtils.degToRad(a);spotLight.penumbra=p;lightAngleValueSpan.innerHTML=`${a}°`;lightPenumbraValueSpan.textContent=p.toFixed(2);}catch(e){logToPage(`Spot params err: ${e.message}`,'error')}}
function onLightPositionChange() { /* ... */ if(!spotLight||!lightVisualizer||!lightXSlider||!lightYSlider||!lightZSlider)return;try{const x=parseFloat(lightXSlider.value);const y=parseFloat(lightYSlider.value);const z=parseFloat(lightZSlider.value);spotLight.position.set(x,y,z);lightVisualizer.position.copy(spotLight.position);updateLightPositionDisplays();}catch(e){logToPage(`Light pos err: ${e.message}`,'error')}}
function updateLightPositionDisplays() { /* ... */ try{if(lightXValueSpan&&lightXSlider)lightXValueSpan.textContent=parseFloat(lightXSlider.value).toFixed(1);if(lightYValueSpan&&lightYSlider)lightYValueSpan.textContent=parseFloat(lightYSlider.value).toFixed(1);if(lightZValueSpan&&lightZSlider)lightZValueSpan.textContent=parseFloat(lightZSlider.value).toFixed(1);}catch(e){logToPage(`Update light disp err: ${e.message}`,'error')}}
async function handleShapeSelectionChange() { /* ... */ const val=shapeSelect.value; logToPage(`Shape change: ${val}`); if(openPoserBtn)openPoserBtn.disabled=true;if(poseSelect)poseSelect.disabled=true;if(refreshPosesBtn)refreshPosesBtn.disabled=true;if(poseSelect)poseSelect.innerHTML='<option value="">Default Pose</option>'; logToPage("Loading new obj...", 'loading'); try{const result=await updateObject(val); if(!result?.object3D){logToPage(`Fail create/load: ${val}`,'error');return;} const newObj=result.object3D;const id=THREE.MathUtils.generateUUID(); newObj.layers.set(INTERACTION_LAYER);newObj.traverse(c=>{c.layers.set(INTERACTION_LAYER);}); logToPage(`Assigned layer ${INTERACTION_LAYER} to ${id}`); logToPage(`Adding ${id} (${result.originalType})...`); newObj.position.set(0,0,0);newObj.rotation.set(0,0,0);newObj.quaternion.setFromEuler(newObj.rotation);newObj.scale.set(1,1,1); scene.add(newObj); const data={uuid:id,originalType:result.originalType,objectType:result.type,object3D:newObj,isPoseable:isPoseableModel(result.originalType)}; sceneObjects.push(data); newObj.updateMatrixWorld(true);const box=new THREE.Box3().setFromObject(newObj,true);let baseY=0;if(!box.isEmpty()&&!box.getSize(new THREE.Vector3()).equals(new THREE.Vector3(0,0,0)))baseY=-box.min.y;else{logToPage(`Warn: Bad BBox ${id}`,'warn');baseY=newObj.position.y;} newObj.position.y=baseY;newObj.updateMatrixWorld(true); logToPage(`Positioned ${id} at Y: ${baseY.toFixed(3)}`); if(result.type==='posed_glb'&&result.poseToApply&&result.object3D.isGroup){const pData=localStorage.getItem(`poses_${result.originalType}`);if(pData){try{const all=JSON.parse(pData);if(all?.[result.poseToApply]){const ok=applyPoseData(newObj,all[result.poseToApply]);logToPage(`Applied saved pose ${result.poseToApply}: ${ok?'OK':'Fail'}`);}else{logToPage(`Pose ${result.poseToApply} not found for ${result.originalType}`,'warn');}}catch(e){logToPage(`Err parse pose ${result.originalType}: ${e.message}`,'error');}}else{logToPage(`No saved poses for ${result.originalType}`,'warn');}}else if(result.type==='posed_glb'&&result.isPoseable){logToPage(`Loaded poseable ${id} default state.`);} populateObjectList();selectObject(id);logToPage(`Object ${id} added & selected.`,'success');}catch(e){logToPage(`Shape change handle err: ${e.message}\n${e.stack}`,'error');}finally{logToPage("Finished loading obj.");}}
function handleSliderReset(event) { /* ... */ if(!event.target.classList.contains('reset-slider-btn'))return; event.stopPropagation(); try{const btn=event.target;const id=btn.dataset.targetSlider;const val=btn.dataset.resetValue;const slider=document.getElementById(id);if(slider&&val!==undefined){slider.value=val;slider.dispatchEvent(new Event('input',{bubbles:true}));logToPage(`Slider ${id} reset to ${val}.`);}else{logToPage(`Reset fail: Slider ${id} or val ${val} bad.`,'error');}}catch(e){logToPage(`Slider reset err: ${e.message}`,'error');}}
function focusCameraOnSelection(smooth=false) { /* ... */ const obj=getSelectedObject3D(); if(!obj){logToPage("Focus: No obj. Focus origin.","info");controls.target.set(0,1,0);const defPos=new THREE.Vector3(0,6,14);if(smooth){logToPage("Smooth focus default NYI.");camera.position.copy(defPos);}else{camera.position.copy(defPos);}controls.update();if(isCameraDecoupled)toggleCameraDecoupling();return;} logToPage(`Focusing camera on ${selectedObjectUUID}`); const center=new THREE.Vector3();const box=new THREE.Box3().setFromObject(obj,true); if(!box.isEmpty()&&!box.getSize(new THREE.Vector3()).equals(new THREE.Vector3(0,0,0))){box.getCenter(center);const size=box.getSize(new THREE.Vector3());const maxD=Math.max(size.x,size.y,size.z);const fitOff=maxD/(2*Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5)));const dist=fitOff+maxD*0.75;const finalDist=THREE.MathUtils.clamp(dist,controls.minDistance,controls.maxDistance);const offset=new THREE.Vector3().subVectors(camera.position,controls.target);offset.normalize().multiplyScalar(finalDist);const newPos=center.clone().add(offset); if(smooth){logToPage("Smooth focus NYI.");camera.position.copy(newPos);controls.target.copy(center);controls.update();}else{camera.position.copy(newPos);controls.target.copy(center);controls.update();} logToPage(`Focused. Target:${center.x.toFixed(1)},${center.y.toFixed(1)},${center.z.toFixed(1)}. Dist:${finalDist.toFixed(1)}`); }else{logToPage("Focus: Bad bounds. Target origin.","warn");controls.target.copy(obj.position);const defPos=new THREE.Vector3(0,6,14);camera.position.copy(defPos);controls.update();} if(isCameraDecoupled)toggleCameraDecoupling();}
function toggleCameraDecoupling() { /* ... */ isCameraDecoupled=!isCameraDecoupled; logToPage(`Cam decouple ${isCameraDecoupled?'ON':'OFF'}.`); if(isCameraDecoupled){decoupleCameraBtn.textContent='Free';decoupleCameraBtn.classList.add('decoupled');controls.enablePan=true;logToPage("Orbit target updates OFF.");}else{decoupleCameraBtn.textContent='Orbit';decoupleCameraBtn.classList.remove('decoupled');controls.enablePan=true;updateTargets();logToPage("Orbit target updates ON.");controls.update();} }
function saveSceneState() { /* ... */ logToPage("Saving state..."); if(!camera||!controls||!spotLight){logToPage("Save fail: Core missing.",'error');return;} try{const objs=sceneObjects.map(oD=>{const o3D=oD.object3D;let matData=null,poseData=null,repMat=null;if(o3D.isMesh&&o3D.material?.isMeshStandardMaterial)repMat=o3D.material;else if(o3D.isGroup)o3D.traverse(c=>{if(!repMat&&c.isMesh&&c.material?.isMeshStandardMaterial)repMat=c.material;}); if(repMat){if(!repMat.map){const hsl={h:0,s:0,l:0};repMat.color.getHSL(hsl);matData={hue:hsl.h,brightness:hsl.l,roughness:repMat.roughness,metalness:repMat.metalness}}else{matData={hue:null,brightness:null,roughness:repMat.roughness,metalness:repMat.metalness}}} if(oD.isPoseable&&o3D.isGroup){const bs=[];o3D.traverse(c=>{if(c.isBone)bs.push(c);});if(bs.length>0){poseData=bs.map(b=>({name:b.name,position:b.position.toArray(),quaternion:b.quaternion.toArray(),scale:b.scale.toArray()}));}} return{uuid:oD.uuid,originalType:oD.originalType,transform:{position:o3D.position.toArray(),quaternion:o3D.quaternion.toArray(),scale:o3D.scale.toArray()},material:matData,poseData:poseData};}); const state={version:1.2,camera:{position:camera.position.toArray(),target:controls.target.toArray()},light:{intensity:parseFloat(lightIntensitySlider.value),angle:parseFloat(lightAngleSlider.value),penumbra:parseFloat(lightPenumbraSlider.value),position:spotLight.position.toArray()},sceneObjects:objs,selectedObjectUUID:selectedObjectUUID,environment:{wall:{hue:parseFloat(wallHueSlider.value),saturation:parseFloat(wallSaturationSlider.value),brightness:parseFloat(wallBrightnessSlider.value)},floor:{hue:parseFloat(floorHueSlider.value),saturation:parseFloat(floorSaturationSlider.value),brightness:parseFloat(floorBrightnessSlider.value)}},helpers:{gridVisible:gridHelperToggle.checked},ui:{controlsCollapsed:document.body.classList.contains('controls-collapsed'),cameraLocked:!controls.enabled,cameraDecoupled:isCameraDecoupled}}; localStorage.setItem(LOCAL_STORAGE_KEY,JSON.stringify(state));logToPage("State saved (v1.2).","success");}catch(e){logToPage(`Save state err: ${e.message}`,'error');console.error(e);}}
async function loadSceneState() { /* ... */ logToPage("Loading state..."); const json=localStorage.getItem(LOCAL_STORAGE_KEY); if(!json){logToPage("No saved state.");return false;} let state; try{state=JSON.parse(json);if(!state||state.version!==1.2){logToPage(`Version mismatch/invalid: ${state?.version}. Ignoring.`,'error');localStorage.removeItem(LOCAL_STORAGE_KEY);return false;} if(!state.sceneObjects||!Array.isArray(state.sceneObjects)){logToPage(`Invalid sceneObjects array. Ignoring.`,'error');localStorage.removeItem(LOCAL_STORAGE_KEY);return false;} logToPage(`State v${state.version} parsed.`);}catch(e){logToPage(`Parse state err: ${e.message}. Clearing.`,'error');console.error(e);localStorage.removeItem(LOCAL_STORAGE_KEY);return false;} try{logToPage("Applying state..."); logToPage("Clearing scene..."); selectObject(null); const uuidsToDelete = sceneObjects.map(o => o.uuid); uuidsToDelete.forEach(uuid => deleteObject(uuid)); if(sceneObjects.length > 0){ logToPage("Warn: Not all objects cleared.", "warn"); sceneObjects.length = 0; } logToPage("Scene cleared."); logToPage("Applying globals..."); controls.enabled=!state.ui.cameraLocked; cameraLockBtn.textContent=controls.enabled?'Lock Camera':'Unlock Camera'; const needsToggle=document.body.classList.contains('controls-collapsed')!==state.ui.controlsCollapsed; if(needsToggle){toggleControls();} if(state.ui.cameraDecoupled!==undefined&&state.ui.cameraDecoupled!==isCameraDecoupled)toggleCameraDecoupling(); camera.position.fromArray(state.camera.position); controls.target.fromArray(state.camera.target); controls.update(); lightIntensitySlider.value=state.light.intensity; lightAngleSlider.value=state.light.angle; lightPenumbraSlider.value=state.light.penumbra; lightXSlider.value=state.light.position[0]; lightYSlider.value=state.light.position[1]; lightZSlider.value=state.light.position[2]; onLightIntensityChange(); onSpotlightParamsChange(); onLightPositionChange(); wallHueSlider.value=state.environment.wall.hue; wallSaturationSlider.value=state.environment.wall.saturation; wallBrightnessSlider.value=state.environment.wall.brightness; floorHueSlider.value=state.environment.floor.hue; floorSaturationSlider.value=state.environment.floor.saturation; floorBrightnessSlider.value=state.environment.floor.brightness; onWallColorChange(); onFloorColorChange(); gridHelperToggle.checked=state.helpers.gridVisible; gridHelper.visible=state.helpers.gridVisible; axesHelper.visible=state.helpers.axesVisible??false; logToPage(`Recreating ${state.sceneObjects.length} objs...`); let lastUUID=state.selectedObjectUUID||null; selectedObjectUUID=null; for(const saved of state.sceneObjects){logToPage(`Recreating: ${saved.uuid} (${saved.originalType})`); const res=await updateObject(saved.originalType);if(!res?.object3D){logToPage(`Fail recreate ${saved.uuid}`,'error');continue;} const obj=res.object3D; obj.uuid=saved.uuid; obj.layers.set(INTERACTION_LAYER);obj.traverse(c=>{c.layers.set(INTERACTION_LAYER);}); if(saved.transform){obj.position.fromArray(saved.transform.position);if(saved.transform.quaternion)obj.quaternion.fromArray(saved.transform.quaternion);else{obj.quaternion.identity();logToPage(`Quat missing ${saved.uuid}`,'warn');}obj.scale.fromArray(saved.transform.scale);obj.updateMatrixWorld(true);}else{logToPage(`No transform ${saved.uuid}`,'warn');obj.updateMatrixWorld(true);const b=new THREE.Box3().setFromObject(obj,true);let by=0;if(!b.isEmpty()&&!b.getSize(new THREE.Vector3()).equals(new THREE.Vector3(0,0,0)))by=-b.min.y;obj.position.set(0,by,0);obj.updateMatrixWorld(true);} if(saved.material){const applyMat=(m,d)=>{if(!m?.isMeshStandardMaterial||!d)return false;if(d.hue!==null&&d.brightness!==null&&!m.map)m.color.setHSL(d.hue,0.8,d.brightness);m.roughness=d.roughness??0.4;m.metalness=d.metalness??0.1;m.needsUpdate=true;return true;};if(obj.isMesh){applyMat(obj.material,saved.material);}else if(obj.isGroup){obj.traverse(c=>{if(c.isMesh){if(Array.isArray(c.material))c.material.forEach(m=>{applyMat(m,saved.material);});else applyMat(c.material,saved.material);}});}} const poseable=isPoseableModel(saved.originalType); if(poseable&&saved.poseData){logToPage(`Applying saved pose ${saved.uuid}`);applyPoseData(obj,saved.poseData);} scene.add(obj); sceneObjects.push({uuid:saved.uuid,originalType:saved.originalType,objectType:res.type,object3D:obj,isPoseable:poseable});} populateObjectList(); if(lastUUID&&sceneObjects.some(o=>o.uuid===lastUUID)){logToPage(`Restoring selection: ${lastUUID}`);selectObject(lastUUID);}else{logToPage("No selection restored.");selectObject(null);} controls.update(); logToPage("State loaded.","success"); return true;}catch(e){logToPage(`Apply state err: ${e.message}\n${e.stack}`,'error');console.error(e);await resetSceneToDefaults();logToPage("Scene reset due to load err.","warn");return false;}}
function toggleControls() { /* ... */ try { const isCollapsed = document.body.classList.toggle('controls-collapsed'); toggleControlsBtn.textContent = isCollapsed ? '▲' : '▼'; toggleControlsBtn.title = isCollapsed ? 'Expand Controls' : 'Collapse Controls'; logToPage(`Controls ${isCollapsed ? 'collapsed' : 'expanded'}.`); setTimeout(onWindowResize, 50); } catch (error) { logToPage(`Error toggling controls: ${error.message}`, 'error'); console.error("Toggle Controls Error:", error); } }
function toggleCameraLock() { /* ... */ try { if (!controls || !cameraLockBtn) return; controls.enabled = !controls.enabled; cameraLockBtn.textContent = controls.enabled ? 'Lock Camera' : 'Unlock Camera'; logToPage(`Camera controls ${controls.enabled ? 'enabled' : 'disabled'}.`); } catch (e) { logToPage(`Camera lock toggle error: ${e.message}`, 'error'); } }
function resetObjectState() { /* ... */ logToPage("Resetting selected object state..."); const obj = getSelectedObject3D(); if (!obj) { logToPage("No object selected.", "info"); return; } logToPage(`Resetting state for: ${selectedObjectUUID}`); try { const ids = ['modelYOffset', 'objectPositionX', 'objectPositionZ', 'objectRotationX', 'objectRotationY', 'objectRotationZ', 'objectScale', 'modelColorHue', 'objectBrightness', 'objectRoughness', 'objectMetalness']; ids.forEach(id => { document.querySelector(`.reset-slider-btn[data-target-slider="${id}"]`)?.click(); }); const data = sceneObjects.find(o => o.uuid === selectedObjectUUID); if (data?.isPoseable && poseSelect) { poseSelect.value = ''; applyPose(''); logToPage("Reset applied default pose."); } logToPage("Selected object state reset via controls."); } catch (e) { logToPage(`Error during object reset: ${e.message}`, 'error'); } }
async function resetSceneToDefaults() { /* ... */ logToPage("Resetting scene..."); try { gridHelperToggle.checked = true; document.body.classList.remove('controls-collapsed'); toggleControls(); toggleControls(); logToPage("UI panel opened."); controls.enabled = true; cameraLockBtn.textContent = 'Lock Camera'; logToPage("UI toggles reset."); logToPage("Clearing objects..."); selectObject(null); while(sceneObjects.length > 0) deleteObject(sceneObjects[sceneObjects.length - 1].uuid); logToPage("Objects cleared."); logToPage("Setting default sliders..."); if(document.querySelector('.reset-slider-btn[data-target-slider="lightIntensity"]')) document.querySelector('.reset-slider-btn[data-target-slider="lightIntensity"]').dataset.resetValue = "3.5"; if(document.querySelector('.reset-slider-btn[data-target-slider="lightAngle"]')) document.querySelector('.reset-slider-btn[data-target-slider="lightAngle"]').dataset.resetValue = "45"; if(document.querySelector('.reset-slider-btn[data-target-slider="lightPenumbra"]')) document.querySelector('.reset-slider-btn[data-target-slider="lightPenumbra"]').dataset.resetValue = "0.20"; if(document.querySelector('.reset-slider-btn[data-target-slider="lightY"]')) document.querySelector('.reset-slider-btn[data-target-slider="lightY"]').dataset.resetValue = "10.0"; if(document.querySelector('.reset-slider-btn[data-target-slider="lightX"]')) document.querySelector('.reset-slider-btn[data-target-slider="lightX"]').dataset.resetValue = "4.0"; if(document.querySelector('.reset-slider-btn[data-target-slider="lightZ"]')) document.querySelector('.reset-slider-btn[data-target-slider="lightZ"]').dataset.resetValue = "0.0"; document.querySelectorAll('#controls-container .reset-slider-btn').forEach(btn => { try { btn.click(); } catch (e) { logToPage(`Err click reset ${btn.dataset.targetSlider}: ${e.message}`, 'warn');} }); logToPage("Default sliders applied."); logToPage("Setting env hues..."); const wallH = Math.random(); const floorH = Math.random(); if(wallHueSlider) wallHueSlider.value = wallH; if(floorHueSlider) floorHueSlider.value = floorH; onWallColorChange(); onFloorColorChange(); logToPage("Selecting random primitive..."); resetShapeDropdown(); const primOpts = Array.from(shapeSelect.querySelectorAll('optgroup[label="Primitives"] option')); let selPrim = 'sphere'; if (primOpts.length > 0) { const idx = Math.floor(Math.random() * primOpts.length); selPrim = primOpts[idx].value; logToPage(`Random primitive: ${selPrim}`); } else { logToPage("No primitives found, default sphere.", 'warn'); } shapeSelect.value = selPrim; await handleShapeSelectionChange(); logToPage("Resetting camera/helpers..."); gridHelper.visible = gridHelperToggle.checked; axesHelper.visible = false; camera.position.set(0, 6, 14); if (isCameraDecoupled) toggleCameraDecoupling(); controls.update(); logToPage("Scene reset complete.", "success"); } catch (error) { logToPage(`Error resetting scene: ${error.message}\n${error.stack}`, 'error'); } }
function handleOpenPoser() { /* ... */ logToPage("Open Poser clicked."); if (!currentModelPath) { logToPage("Cannot open poser: No poseable selected.", 'error'); alert("Select poseable model first."); return; } if (!isPoseableModel(currentModelPath)) { logToPage(`Cannot open poser: ${currentModelPath} not poseable.`, 'warn'); alert("Selected object not poseable."); return; } const url = `poser.html?model=${encodeURIComponent(currentModelPath)}`; logToPage(`Opening poser: ${currentModelPath}`); const win = window.open(url, '_blank'); if (!win) { logToPage("Failed to open poser window.", 'error'); alert("Pop-up blocked?"); } else { logToPage("Poser window opened.", "success"); } }

// --- Animation Loop Definition ---
function animate() {
    try { requestAnimationFrame(animate); if (controls?.enabled) controls.update(); if (renderer && scene && camera) renderer.render(scene, camera); }
    catch (e) { logToPage(`Anim loop err: ${e.message}`, 'error'); }
}

// --- Initialization Function Definition ---
async function init() {
    try {
        logToPage("Init started...");
        getDOMElements(); // <<< Call is now safe
        logToPage("DOM elements retrieved.");
        storeOriginalOptions();
        scene = new THREE.Scene(); logToPage("Scene created.");
        raycaster = new THREE.Raycaster(); logToPage("Raycaster initialized.");
        const aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
        camera = new THREE.PerspectiveCamera(60, aspect > 0 ? aspect : 1, 0.1, 100); camera.layers.enableAll(); logToPage("Camera created.");
        renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0; sceneContainer.appendChild(renderer.domElement); logToPage("Renderer created.");
        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambientLight);
        spotLight = new THREE.SpotLight(0xffffff, 1.0, 150, 1.0, 0, 1); spotLight.castShadow = true; spotLight.shadow.mapSize.set(1024,1024); spotLight.shadow.camera.near = 0.5; spotLight.shadow.camera.far = 50; spotLight.shadow.bias = -0.001; spotLight.layers.disable(INTERACTION_LAYER); scene.add(spotLight);
        lightTarget = new THREE.Object3D(); lightTarget.layers.disable(INTERACTION_LAYER); scene.add(lightTarget); spotLight.target = lightTarget;
        const lightGeo = new THREE.SphereGeometry(0.2, 16, 8); const lightMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); lightVisualizer = new THREE.Mesh(lightGeo, lightMat); lightVisualizer.layers.disable(INTERACTION_LAYER); scene.add(lightVisualizer); logToPage("Lights setup.");
        // --- Floor ---
        const floorGeo = new THREE.PlaneGeometry(40, 40); floorBaseMaterial = { roughness: 0.9, metalness: 0.1 }; const floorMat = new THREE.MeshStandardMaterial({ ...floorBaseMaterial, color: 0x808080 }); floor = new THREE.Mesh(floorGeo, floorMat); floor.rotation.x = -Math.PI / 2; floor.position.y = 0; floor.receiveShadow = true; floor.layers.disable(INTERACTION_LAYER); scene.add(floor); logToPage("Floor added.");
        // --- Helpers ---
        gridHelper = new THREE.GridHelper(40, 40, 0x888888, 0x444444); axesHelper = new THREE.AxesHelper(3); gridHelper.layers.disable(INTERACTION_LAYER); axesHelper.layers.disable(INTERACTION_LAYER); scene.add(gridHelper); scene.add(axesHelper); logToPage("Helpers added.");
        // --- Controls ---
        controls = new OrbitControls(camera, renderer.domElement); controls.enabled = true; controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false; controls.maxPolarAngle = Math.PI / 2 - 0.01; controls.minDistance = 2; controls.maxDistance = 50; controls.update(); logToPage("OrbitControls added.");
        objectMaterial = new THREE.MeshStandardMaterial({ color: 0x3399ff, roughness: 0.4, metalness: 0.1, side: THREE.DoubleSide }); logToPage("Base material created.");
        // --- Event Listeners ---
        window.addEventListener('resize', onWindowResize, false); // <<< Definition is now safely above
        toggleControlsBtn.addEventListener('click', toggleControls); refreshShapeListBtn.addEventListener('click', resetShapeDropdown); cameraLockBtn.addEventListener('click', toggleCameraLock); gridHelperToggle.addEventListener('change', () => { gridHelper.visible = gridHelperToggle.checked; }); resetObjectBtn.addEventListener('click', resetObjectState);
        wallHueSlider.addEventListener('input', onWallColorChange); wallSaturationSlider.addEventListener('input', onWallColorChange); wallBrightnessSlider.addEventListener('input', onWallColorChange); floorHueSlider.addEventListener('input', onFloorColorChange); floorSaturationSlider.addEventListener('input', onFloorColorChange); floorBrightnessSlider.addEventListener('input', onFloorColorChange);
        modelYOffsetSlider.addEventListener('input', onModelYOffsetChange);
        // objectPositionXSlider.addEventListener('input', onObjectPositionChange); // <<< REMOVED Pos X Listener
        // objectPositionZSlider.addEventListener('input', onObjectPositionChange); // <<< REMOVED Pos Z Listener
        objectRotationXSlider.addEventListener('input', onObjectRotationChange); objectRotationYSlider.addEventListener('input', onObjectRotationChange); objectRotationZSlider.addEventListener('input', onObjectRotationChange); objectScaleSlider.addEventListener('input', onObjectScaleChange); modelColorHueSlider.addEventListener('input', onModelColorOrBrightnessChange); objectBrightnessSlider.addEventListener('input', onModelColorOrBrightnessChange); objectRoughnessSlider.addEventListener('input', onObjectMaterialChange); objectMetalnessSlider.addEventListener('input', onObjectMaterialChange);
        lightIntensitySlider.addEventListener('input', onLightIntensityChange); lightAngleSlider.addEventListener('input', onSpotlightParamsChange); lightPenumbraSlider.addEventListener('input', onSpotlightParamsChange); lightXSlider.addEventListener('input', onLightPositionChange); lightYSlider.addEventListener('input', onLightPositionChange); lightZSlider.addEventListener('input', onLightPositionChange);
        shapeSelect.addEventListener('change', handleShapeSelectionChange); shapeSearchInput.addEventListener('input', filterShapeDropdown); copyLogBtn.addEventListener('click', () => { try { navigator.clipboard.writeText(debugConsole.innerText || debugConsole.textContent).then(() => logToPage('Log copied.', 'success')).catch(err => logToPage(`Copy fail: ${err}`, 'error')); } catch (e) { logToPage(`Copy log error: ${e.message}`, 'error'); } });
        controlsContainer.addEventListener('click', handleSliderReset); saveStateBtn?.addEventListener('click', saveSceneState); loadStateBtn?.addEventListener('click', async () => { await loadSceneState(); }); resetSceneBtn?.addEventListener('click', async () => { await resetSceneToDefaults(); });
        poseSelect?.addEventListener('change', (event) => { applyPose(event.target.value); }); openPoserBtn?.addEventListener('click', handleOpenPoser); refreshPosesBtn?.addEventListener('click', () => { const d = sceneObjects.find(o => o.uuid === selectedObjectUUID); if(d?.isPoseable) { loadPosesForModel(d.originalType); } else { logToPage("Refresh poses: No poseable selected.", "warn"); } });
        renderer.domElement.addEventListener('click', onSceneClick, false); focusCameraBtn?.addEventListener('click', () => focusCameraOnSelection(false)); decoupleCameraBtn?.addEventListener('click', toggleCameraDecoupling);
        logToPage("Event listeners added.");
        // --- Apply Initial State ---
        await resetSceneToDefaults(); logToPage("Skipping auto load state during dev."); populateObjectList();
        animate(); // <<< START Animation Loop >>>
        logToPage("Init complete, loop started.", "success");
    } catch (error) { logToPage(`Initialization Error: ${error.message}\n${error.stack}`, 'error'); if(sceneContainer){ sceneContainer.innerHTML = `<p style='color:red;padding:20px;'>Init Error: ${error.message}<br>Check Log.</p>`; } else { alert(`Init Error: ${error.message}`); } }
}

// --- Run Initialization Function Definition ---
async function runInitialization() { logToPage("Running init..."); try { await init(); } catch (error) { logToPage(`RunInit Error: ${error.message}`, 'error'); console.error(error); if(sceneContainer) sceneContainer.innerHTML = `<p style='color:red;padding:20px;'>Init Error: ${error.message}<br>Check Log.</p>`; } }


// --- Start Execution (Placed at the VERY END) ---
logToPage("Checking DOM state...");
if (document.readyState === 'loading') { logToPage("DOM not ready, add listener."); document.addEventListener('DOMContentLoaded', runInitialization); }
else { logToPage("DOM ready, run init."); runInitialization(); }
